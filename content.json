{"pages":[{"title":"About","date":"2024-05-29T03:00:36.210Z","path":"about/index.html","text":""},{"title":"Categories","date":"2024-05-29T03:00:36.230Z","path":"categories/index.html","text":""},{"title":"search","date":"2023-12-28T01:29:24.000Z","path":"search/index.html","text":""},{"title":"search","date":"2023-12-28T01:30:39.000Z","path":"search/index-1.html","text":""},{"title":"Tags","date":"2024-05-29T03:00:36.231Z","path":"tags/index.html","text":""},{"title":"","date":"2023-12-30T09:42:02.302Z","path":"categories/index.html","text":""},{"title":"导航站","date":"2024-09-20T08:24:54.000Z","path":"sitemap/index.html","text":"工具类 聚合搜索 AI站点 百川大模型 智普AI ChatGPT 文心一言 豆包 Kimi 技术博客 阮一峰的网络日志 崔亮的博客 云原生之路 Prometheus 中文文档 Prometheus 官方文档-中文"}],"posts":[{"title":"在Prometheus的rule文件中使用判断语句和变量","date":"2024-10-08T08:55:26.000Z","path":"posts/25711707/","text":"话不多说，直接给出示例，相信一眼就能看到怎么用了 12345678910- name: hostStatsAlert300s interval: 5m rules: - alert: 磁盘使用率超过阈值告警 expr: ((node_filesystem_size_bytes - node_filesystem_avail_bytes) / node_filesystem_size_bytes) * on(instance) group_left(nodename) (node_uname_info) &gt; 0.7 labels: severity: &quot;&#123;&#123; if gt $value 0.9 &#125;&#125; 紧急告警 &#123;&#123; else if gt $value 0.8 &#125;&#125; 重要告警 &#123;&#123; else if gt $value 0.7 &#125;&#125; 次要告警 &#123;&#123; end &#125;&#125;&quot; annotations: summary: &quot;主机 &#123;&#123; $labels.nodename &#125;&#125; 目录 &#123;&#123; $labels.mountpoint &#125;&#125; 磁盘使用率过高&quot; description: &quot;主机&#123;&#123; $labels.nodename &#125;&#125; 磁盘使用率过高，告警阈值：&#123;&#123; if gt $value 0.9 &#125;&#125;90%&#123;&#123; else if gt $value 0.8 &#125;&#125;80%&#123;&#123; else if gt $value 0.7 &#125;&#125;70%&#123;&#123; end &#125;&#125;，当前使用率：&#123;&#123; $value | humanizePercentage &#125;&#125;，目录：&#123;&#123; $labels.mountpoint &#125;&#125;&quot; $labels：在web界面查询出来的所有标签值都能用 $value：警报触发时的表达式计算结果","tags":[{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/tags/Prometheus/"}],"categories":[{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/categories/Prometheus/"}]},{"title":"Prometheus告警中如何携带主机名","date":"2024-10-08T08:48:43.000Z","path":"posts/cbb5ee1c/","text":"主机名（nodename）在指标node_uname_info中，且node_uname_info的值恰巧为1，所以我们可以在PromQL中通过node_uname_info提取，只需要在原有PromQL后添加 1* on(instance) group_left(nodename) (node_uname_info) 这样，在prometheus告警的labels中，就可以通过nodename获取主机名了 比如原先的expr为 1node_filesystem_size_bytes - node_filesystem_avail_bytes) / node_filesystem_size_bytes &gt; 0.7 修改为以下的expr就行 1((node_filesystem_size_bytes - node_filesystem_avail_bytes) / node_filesystem_size_bytes) * on (instance) group_left (nodename) (node_uname_info) &gt; 0.7 参考资料 Prometheus监控，生产可用告警规则（可获取主机名）","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"},{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/tags/Prometheus/"}],"categories":[{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/categories/Prometheus/"}]},{"title":"热重载Prometheus和AlertManager配置文件","date":"2024-10-08T08:05:40.000Z","path":"posts/ed0140b7/","text":"如果每次修改配置文件都需要重启服务，那就太操蛋了。 Prometheus配置文件重载 必要条件：Prometheus在2.0版本后hot reload 功能是默认关闭的，如需开启，需要在启动Prometheus的时候，添加 --web.enable-lifecycle 参数。 12# Docker 运行示例docker run -d --name prom-server prometheus --web.enable-lifecycle --config.file=/etc/prometheus/prometheus.yml 重载文件 12curl -X POST http://WEBURL/-/reload 接下来就可以看文件有没有reload日志打印了 123456ts=2024-10-08T07:38:57.506Z caller=main.go:1367 level=info msg=&quot;Loading configuration file&quot; filename=/etc/prometheus/prometheus.ymlts=2024-10-08T07:38:57.508Z caller=main.go:1415 level=info msg=&quot;Completed loading of configuration file&quot; filename=/etc/prometheus/prometheus.yml totalDuration=1.791304ms db_storage=1.533µs remote_storage=1.493µs web_handler=471ns query_engine=1.122µs scrape=74.5µs scrape_sd=39.955µs notify=17.532µs notify_sd=11.622µs rules=1.293589ms tracing=2.935µsts=2024-10-08T07:39:24.210Z caller=main.go:1367 level=info msg=&quot;Loading configuration file&quot; filename=/etc/prometheus/prometheus.ymlts=2024-10-08T07:39:24.212Z caller=main.go:1415 level=info msg=&quot;Completed loading of configuration file&quot; filename=/etc/prometheus/prometheus.yml totalDuration=1.753011ms db_storage=1.512µs remote_storage=1.503µs web_handler=541ns query_engine=1.182µs scrape=84.148µs scrape_sd=37.81µs notify=15.93µs notify_sd=9.338µs rules=1.194914ms tracing=3.727µsts=2024-10-08T08:02:58.620Z caller=main.go:1367 level=info msg=&quot;Loading configuration file&quot; filename=/etc/prometheus/prometheus.ymlts=2024-10-08T08:02:58.622Z caller=main.go:1415 level=info msg=&quot;Completed loading of configuration file&quot; filename=/etc/prometheus/prometheus.yml totalDuration=1.705142ms db_storage=1.603µs remote_storage=1.803µs web_handler=501ns query_engine=1.062µs scrape=81.222µs scrape_sd=34.655µs notify=15.208µs notify_sd=10.019µs rules=1.183322ms tracing=3.437µs AlertManager文件重载 AlertManager默认支持热重载文件，通过以下命令进行重载操作。 1http://WEBURL/-/reload 查看日志是否有reload 12ts=2024-10-08T08:13:15.421Z caller=coordinator.go:113 level=info component=configuration msg=&quot;Loading configuration file&quot; file=/etc/alertmanager/alertmanager.ymlts=2024-10-08T08:13:15.422Z caller=coordinator.go:126 level=info component=configuration msg=&quot;Completed loading of configuration file&quot; file=/etc/alertmanager/alertmanager.yml","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"},{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/tags/Prometheus/"},{"name":"AlertManager","slug":"AlertManager","permalink":"https://www.esearch.top/tags/AlertManager/"}],"categories":[{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/categories/Prometheus/"}]},{"title":"Prometheus-AlertManager设置邮件发送告警信息","date":"2024-10-05T09:36:08.000Z","path":"posts/6bafdf3f/","text":"以网易163邮箱为例 修改alertmanager.yml文件 12345678910111213141516171819202122global: resolve_timeout: 5m # 当警报恢复后，等待这个时长才认为警报真正解决 smtp_from: &#x27;xxxx@163.com&#x27; # 发送警报邮件的发件人邮箱地址 smtp_smarthost: &#x27;smtp.163.com:465&#x27; # 邮件发送使用的SMTP服务器地址和端口 smtp_auth_username: &#x27;xxx@163.com&#x27; # 用于SMTP认证的用户名，通常是发件人的邮箱地址 smtp_auth_password: &#x27;xxxxxxx&#x27; # 用于SMTP认证的密码，这里应该是邮箱的授权码（token），而非登录密码 smtp_require_tls: false # 是否要求使用TLS加密邮件传输，这里设置为false表示不强制要求 smtp_hello: &#x27;163.com&#x27; # SMTP连接时的HELO/EHLO标识，通常使用邮件服务商的域名route: group_by: [&#x27;alertname&#x27;] # 按照警报名称对警报进行分组 group_wait: 30s # 在将警报发送给接收者之前等待的时间，以便收集更多相关警报 group_interval: 5m # 分组后，每隔这个时长检查一次是否有新警报加入同一分组 repeat_interval: 1h # 对于同一个分组的警报，每隔这个时长重复发送一次通知 receiver: &#x27;163email&#x27; # 默认的警报通知接收者，这里引用了下面定义的receivers中的一个# receivers中定义了警报通知的接收者，包括他们的联系方式receivers: - name: &#x27;163email&#x27; # 接收者的名称，用于在route中引用 email_configs: - to: &#x27;xxx@yeah.net&#x27; # 接收警报邮件的邮箱地址 send_resolved: true # 当警报恢复时，是否发送恢复通知邮件","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"},{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/tags/Prometheus/"},{"name":"AlertManager","slug":"AlertManager","permalink":"https://www.esearch.top/tags/AlertManager/"}],"categories":[{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/categories/Prometheus/"}]},{"title":"Prometheus基于文件的自动发现","date":"2024-10-05T09:05:05.000Z","path":"posts/13b4287e/","text":"一、自动发现服务 每次修改Prometheus配置文件都需要重载服务，未免有些麻烦，而自动发现服务就是为了解决这种麻烦事儿的，自动发现服务又分为好几种，其中基于文件的服务发现是最通用的方式。这种方式不需要依赖于任何的平台或者第三方服务。Prometheus会定时从文件中读取最新的Target信息，因此，我们可以通过任意的方式将监控Target的信息写入即可。 二、配置 步骤1 修改prometheus.yml文件 1234- job_name: &#x27;file_sd_default&#x27; file_sd_configs: - files: [&#x27;/etc/prometheus/config/sd_config/*.yml&#x27;] refresh_interval: 5s file_sd_configs：说明配置为基于文件的自动发现服务 files：文件存放位置 refresh_interval: 读取的周期 步骤2 创建targets文件 创建文件 1touch /etc/prometheus/config/sd_config/xxx.yml 写入targets 12- targets: - &#x27;localhost:9090&#x27; 如果需要添加验证，则需要在jobs添加 修改prometheus.yml文件 12345678scrape_configs: - job_name: &#x27;file_sd_node&#x27; file_sd_configs: - files: [&#x27;/etc/prometheus/config/sd_config/node/node.yml&#x27;] refresh_interval: 5s basic_auth: username: 用户名 password: 密码 通过这种方式，Prometheus会自动的周期性读取文件中的内容。当文件中定义的内容发生变化时，不需要对Prometheus进行任何的重启操作。 Targets可以通过Promethtus的web界面，Status &gt; Targets查看 三、Rule的自动加载 Rule无法使用Targets的方式，推荐办法是在修改完Rule之后，使用以下命令进行配置的重新加载（不是重启）。 123sudo kill -HUP $(pgrep prometheus)# 或者使用curl方式curl -X POST http://WEBIP/-/reload HUP信号 全称：Hang Up signal。 用途：当进程接收到HUP信号时，它通常会执行挂起操作，这通常意味着进程会关闭打开的文件描述符并重新读取其配置文件。对于许多守护进程（daemon）来说，HUP信号是一个请求进程重新加载配置文件的常用方式。 常见使用场景：HUP信号常用于服务的平滑重启，特别是对于那些需要持续运行且不能轻易停止的服务。通过发送HUP信号，可以让服务在不中断的情况下重新加载配置。因此，当你执行sudo kill -HUP pgrep prometheus命令时，你实际上是在告诉系统向所有名为prometheus的进程发送一个HUP信号，请求它们重新加载配置文件。这对于Prometheus这样的监控服务非常有用，因为它允许管理员在不中断监控服务的情况下更新配置。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"},{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/tags/Prometheus/"}],"categories":[{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/categories/Prometheus/"}]},{"title":"阿里云-使用Prometheus配置报警规则的最佳实践","date":"2024-10-04T06:55:12.000Z","path":"posts/68a5e006/","text":"使用Prometheus配置报警规则的最佳实践 - 阿里云 ACK从集群稳定性、集群节点异常、集群节点水位、应用容器副本异常、工作负载异常、存储异常、网络异常等多个方面，通过集群、应用的运维经验沉淀，总结梳理出以下Prometheus重要报警规则配置。 报警规则包含容器副本异常、工作负载异常等内容，分为以下级别。 Critical：造成集群、应用、甚至业务影响，需要立即处理。 Warning：造成集群、应用、甚至业务影响，需要尽快排查。 Normal：涉及重要功能变更。 报警规则说明 ACK从集群稳定性、集群节点异常、集群节点水位、应用容器副本异常、工作负载异常、存储异常、网络异常等多个方面，通过集群、应用的运维经验沉淀，总结梳理出以下Prometheus重要报警规则配置。 容器副本异常 详细描述 重要级别 PromQL配置 规则说明 常见处理SOP流程 Pod状态异常 Critical min_over_time(sum by (namespace, pod, phase) (kube_pod_status_phase&#123;phase=~&quot;Pending|Unknown|Failed&quot;&#125;)[5m:1m]) &gt; 0 最近5分钟内，Pod的状态有异常时，触发报警。 关于Pod状态异常的处理方法，请参见Pod异常问题排查。 Pod启动失败 Critical sum_over_time(increase(kube_pod_container_status_restarts_total&#123;&#125;)[5m:1m]) &gt; 3 最近5分钟内，Pod启动异常累计3次以上时，触发报警。 关于Pod启动失败的处理方法，请参见Pod异常问题排查。 超1000个Pod调度失败异常 Critical sum(sum(max_over_time(kube_pod_status_phase&#123; phase=~&quot;Pending&quot;&#125;[5m])) by (pod)) &gt; 1000 最近5分钟内，累计有1000个Pod处于调度失败Pending状态时，触发报警。 可能是大规模集群调度场景下任务压力过大引起的。推荐使用ACK集群Pro版。 容器CPU限流频繁 Warning rate(container_cpu_cfs_throttled_seconds_total[3m]) * 100 &gt; 25 容器CPU被频繁限流。最近3分钟内，被限流的CPU时间片大于25%时，触发报警。 针对这种情况，请评估Pod的CPU资源Limit是否配置过小。推荐使用CPU Burst性能优化策略。 容器副本Pod的CPU资源水位高于85% Warning sum(irate(container_cpu_usage_seconds_total&#123;pod=~&quot;&#123;&#123;PodName&#125;&#125;.*&quot;,namespace=~&quot;&#123;&#123;Namespace&#125;&#125;.*&quot;,container!=&quot;&quot;,container!=&quot;POD&quot;&#125;[1m])) by (namespace,pod) / sum(container_spec_cpu_quota&#123;pod=~&quot;&#123;&#123;PodName&#125;&#125;.*&quot;,namespace=~&quot;&#123;&#123;Namespace&#125;&#125;.*&quot;,container!=&quot;&quot;,container!=&quot;POD&quot;&#125;/100000) by (namespace,pod) * 100 &lt;= 100 or on() vector(0) &gt;= 85 在指定命名空间或Pod下，容器副本Pod的CPU资源水位超过Pod Limit的85%时，会触发报警。 当Pod的CPU资源水位较高时，会造成CPU资源限流，导致CPU时间片分配不足，最终影响Pod中进程的执行。 容器副本Pod的内存资源水位高于85% Warning (sum(container_memory_working_set_bytes&#123;pod=~&quot;&#123;&#123;PodName&#125;&#125;.*&quot;,namespace=~&quot;&#123;&#123;Namespace&#125;&#125;.*&quot;,container !=&quot;&quot;,container!=&quot;POD&quot;&#125;) by (pod,namespace)/ sum(container_spec_memory_limit_bytes&#123;pod=~&quot;&#123;&#123;PodName&#125;&#125;.*&quot;,namespace=~&quot;&#123;&#123;Namespace&#125;&#125;.*&quot;,container !=&quot;&quot;,container!=&quot;POD&quot;&#125;) by (pod, namespace) * 100) &lt;= 100 or on() vector(0) &gt;= 85 容器副本Pod的内存资源水位高于Pod Limit的85%时，触发报警。 当Pod的内存资源水位较高时，会造成Pod被OOMKilled，继而导致Pod重启。 工作负载异常 详细描述 重要级别 PromQL配置 规则说明 常见处理SOP流程 Deployment可用副本状态异常 Critical kube_deployment_spec_replicas&#123;&#125; != kube_deployment_status_replicas_available&#123;&#125; Deployment可用副本数未达到预期时，触发报警。 确定是否有Deployment的Pod启动失败。 DaemonSet副本状态异常 Critical ((100 - kube_daemonset_status_number_ready&#123;&#125; / kube_daemonset_status_desired_number_scheduled&#123;&#125; * 100) or (kube_daemonset_status_desired_number_scheduled&#123;&#125; - kube_daemonset_status_current_number_scheduled&#123;&#125;)) &gt; 0 DaemonSet的可用副本数未达到预期时，触发报警。 确定是否有Deployment的Pod启动失败。 DaemonSet副本调度异常 Critical kube_daemonset_status_number_misscheduled&#123;job&#125; &gt; 0 DaemonSet的副本调度异常时，触发报警。 确定是否有Deployment的Pod启动失败。 Job运行失败 Critical kube_job_status_failed&#123;&#125; &gt; 0 Job执行失败时，触发报警。 在对应Job下的Pod的日志中查看详细失败信息。 存储异常 详细描述 重要级别 PromQL配置 规则说明 常见处理SOP流程 PersistentVolume状态异常 Critical kube_persistentvolume_status_phase&#123;phase=~&quot;Failed|Pending&quot;&#125; &gt; 0 存储卷PV状态异常时，触发报警。 关于PersistentVolume状态异常的处理方法，请参见云盘存储卷FAQ的云盘挂载内容。 节点磁盘空间不足10% Critical ((node_filesystem_avail_bytes * 100) / node_filesystem_size_bytes) &lt; 10 节点某磁盘块设备可用空间不足10%时，触发报警。 建议扩容节点和节点磁盘。 节点状态异常 详细描述 重要级别 PromQL配置 规则说明 常见处理SOP流程 节点NotReady状态持续3分钟 Critical (sum(max_over_time(kube_node_status_condition&#123;condition=&quot;Ready&quot;,status=&quot;true&quot;&#125;[3m]) &lt;= 0) by (node)) or (absent(kube_node_status_condition&#123;condition=&quot;Ready&quot;,status=&quot;true&quot;&#125;)) &gt; 0 集群节点NotReady状态持续3分钟时，触发报警。 确定节点NotReady状态是否符合预期。 宿主机水位异常 详细描述 重要级别 PromQL配置 规则说明 常见处理SOP流程 宿主机内存水位高于85% Warning (100 - node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes * 100) &gt;= 85 该集群的宿主机内存水位高于85%时，触发报警。 释放资源。推荐使用成本洞察功能检查是否有Pod占用了可调度资源。 宿主机内存水位高于90% Critical (100 - node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes * 100) &gt;= 90 该集群的宿主机内存水位高于90%。 释放资源。推荐使用成本洞察功能检查是否有Pod占用了可调度资源。 宿主机CPU水位高于85% Warning 100 - (avg by(instance) (rate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[2m])) * 100) &gt;= 85 该集群的宿主机CPU水位高于85%时，触发报警。 释放资源。推荐使用成本洞察功能检查是否有Pod占用了可调度资源。 宿主机CPU水位高于90% Critical 100 - (avg by(instance) (rate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[2m])) * 100) &gt;= 90 该集群的宿主机CPU水位高于90%时，触发报警。 释放资源。推荐使用成本洞察功能检查是否有Pod占用了可调度资源。 节点资源异常 详细描述 重要级别 PromQL配置 规则说明 常见处理SOP流程 节点CPU资源分配率高于85% Normal (sum(sum(kube_pod_container_resource_requests&#123;resource=&quot;cpu&quot;&#125;) by (pod, node) * on (pod) group_left max(kube_pod_status_ready) by (pod, node)) by (node)) / sum(kube_node_status_allocatable&#123;resource=&quot;cpu&quot;&#125;) by (node) * 100 &gt;= 85 该集群节点的CPU已分配水位高于85%时，触发报警。 该节点可再被调度的资源不足，超过可分配规格的Pod需要被调度到其他节点。 节点CPU超卖率高于300% Warning (sum(sum(kube_pod_container_resource_limits&#123;resource=&quot;cpu&quot;&#125;) by (pod, node) * on (pod) group_left max(kube_pod_status_ready) by (pod, node)) by (node)) / sum(kube_node_status_allocatable&#123;resource=&quot;cpu&quot;&#125;) by (node) * 100 &gt;= 300 该集群节点的CPU超卖水位高于300%时，触发报警。 节点上已调度的Pod的资源Limit的总和远大于节点总可分配资源。 节点内存使用水位高于85% Warning sum(container_memory_working_set_bytes&#123;pod!=&quot;&quot;&#125;) by (node) / sum(kube_node_status_allocatable&#123;resource=&quot;memory&quot;&#125;) by (node) * 100 &gt;= 85 该集群节点的内存水位高于85%时，触发报警。 释放资源。推荐使用成本洞察功能检查是否有Pod占用了可调度资源。 节点内存资源分配率高于85% Normal (sum(sum(kube_pod_container_resource_requests&#123;resource=&quot;memory&quot;&#125;) by (pod, node) * on (pod) group_left max(kube_pod_status_ready) by (pod, node)) by (node)) / sum(kube_node_status_allocatable&#123;resource=&quot;memory&quot;&#125;) by (node) * 100 &gt;= 85 该集群节点的内存已分配水位高于85%时，触发报警。 该节点可再被调度的资源不足，超过可分配规格的Pod需要被调度到其他节点。 节点内存超卖率高于300% Warning (sum(sum(kube_pod_container_resource_limits&#123;resource=&quot;memory&quot;&#125;) by (pod, node) * on (pod) group_left max(kube_pod_status_ready) by (pod, node)) by (node)) / sum(kube_node_status_allocatable&#123;resource=&quot;memory&quot;&#125;) by (node) * 100 &gt;= 300 该集群节点的内存超卖水位高于300%时，触发报警。 节点上已调度的Pod的资源限制Limit的总和远大于节点总可分配资源。 网络异常 详细描述 重要级别 PromQL配置 规则说明 常见处理SOP流程 集群CoreDNS可用性异常-请求跌零 Critical (sum(rate(coredns_dns_request_count_total&#123;&#125;[1m]))by(server,zone)&lt;=0) or (sum(rate(coredns_dns_requests_total&#123;&#125;[1m]))by(server,zone)&lt;=0) 仅ACK托管集群（Pro版、基础版）支持检测该异常。 检查集群中CoreDNS Pod是否正常。 集群CoreDNS可用性异常-panic异常 Critical sum(rate(coredns_panic_count_total&#123;&#125;[3m])) &gt; 0 仅ACK托管集群（Pro版、基础版）支持检测该异常。 检查集群中CoreDNS Pod是否正常。若CoreDNS行为不符合预期，请提交工单咨询。 集群IngressController证书即将过期 Warning ((nginx_ingress_controller_ssl_expire_time_seconds - time()) / 24 / 3600) &lt; 14 您需要安装部署ACK Ingress Controller组件，并开启Ingress功能。 重新签发Ingress Controller证书。 弹性伸缩异常 详细描述 重要级别 PromQL配置 规则说明 常见处理SOP流程 HPA当前副本数已达最大副本设置数 Warning max(kube_horizontalpodautoscaler_spec_max_replicas) by (namespace, horizontalpodautoscaler) - max(kube_horizontalpodautoscaler_status_current_replicas) by (namespace, horizontalpodautoscaler) &lt;= 0 您需要在阿里云Prometheus启用horizontalpodautoscaler相关指标（默认关闭）。此指标为免费指标。 请检查HPA策略是否符合预期。 说明： 规则说明中的操作入口指报警配置页面的报警规则管理页签。您可以登录容器服务管理控制台，在集群列表页面，单击目标集群名称，然后在左侧导航栏，选择报警配置。在报警配置页面，单击报警规则管理页签，进行对应报警规则的更新。 85%的默认阈值为推荐的参考值，实际取值可以以您的业务情况为准。 针对某些报警规则，可能需要根据实际情况调整PromQL配置中的参数，以适应不同的监控需求。 参考资料 使用Prometheus配置报警规则的最佳实践","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"},{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/tags/Prometheus/"}],"categories":[{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/categories/Prometheus/"}]},{"title":"node_exporter添加访问验证","date":"2024-10-03T07:46:13.000Z","path":"posts/3b0a5d69/","text":"假设你想要求所有访问Prometheus实例的用户提供用户名和密码。为了这个例子，使用admin作为用户名，并选择任何你喜欢的密码。 步骤1：密码哈希 首先，生成密码的bcrypt哈希值。为了生成哈希密码，我们将使用python3-bcrypt。让我们通过运行apt install python3-bcrypt来安装它，假设你正在运行类似debian的发行版。其他替代方案也存在来生成哈希密码；为了测试，你也可以使用网上的bcrypt生成器。 这里是一个使用python3-bcrypt的python脚本，它会提示你输入密码并对其进行哈希处理： 1234567import getpassimport bcrypt# 提示输入密码password = getpass.getpass(&quot;password: &quot;)hashed_password = bcrypt.hashpw(password.encode(&quot;utf-8&quot;), bcrypt.gensalt())# 获取密码的哈希值print(hashed_password.decode()) 步骤2：创建web.yml 让我们创建一个web.yml文件，内容如下： 12basic_auth_users: admin: $2b$12$hNf2lSsxfm0.i4a.1kVpSOVyBCfIB51VRjgBUyv6kdnyTlgWj81Ay 注意用户名:【空格】密码 你可以使用promtool check web-config web.yml来验证该文件 步骤3：启动Prometheus 你可以使用web配置文件来启动prometheus： 1$ prometheus --web.config.file=web.yml 步骤4：测试 123curl -u admin http://localhost:9090/metrics （可选）步骤5：node_exporter以docker的方式运行 在原有运行容器的命令中加上--web.config.file=/xxx/xxx/web.yml 1234# 原有命令docker run -d --net=&quot;host&quot; --pid=&quot;host&quot; -v &quot;/:/host:ro,rslave&quot; --name prom-node quay.io/prometheus/node-exporter:latest --path.rootfs=/host# 启用验证命令docker run -d --net=&quot;host&quot; --pid=&quot;host&quot; -v &quot;/:/host:ro,rslave&quot; --name prom-node quay.io/prometheus/node-exporter:latest --path.rootfs=/host --web.config.file=/host/data/prometheus/config.yml 步骤6：在server端的prometheus.yml添加验证信息 123456- job_name: &#x27;node&#x27; static_configs: - targets: [&#x27;xxx.xxx.xxx.xxx:9100&#x27;] basic_auth: username: admin # 用户名 password: xxxx # 明文密码 步骤7：测试验证 登录到server前台，验证是否能够获取node数据 参考资料 Securing Prometheus API and UI endpoints using basic auth","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"},{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/tags/Prometheus/"}],"categories":[{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/categories/Prometheus/"}]},{"title":"nginx 代理设置访问密码（不依赖htpasswd工具）","date":"2024-10-03T03:12:29.000Z","path":"posts/f2baa4c/","text":"Nginx访问密码配置（无需htpasswd） 要在Nginx中配置访问密码而不依赖于htpasswd等第三方工具，可以按照以下步骤手动创建密码文件并在Nginx配置中引用它。 步骤1：创建密码文件 生成加密密码：使用编程语言或在线工具生成加密密码。例如，使用Python的crypt模块： 12import cryptprint(crypt.crypt(&quot;your_password&quot;, &quot;salt&quot;)) 保存密码文件：创建一个文本文件（如passwords），并将加密后的密码保存在其中，格式为： 1username:$apr1$...$... 存放密码文件：将passwords文件放置在安全的位置，如/etc/nginx/目录下。 步骤2：编辑Nginx配置文件 打开配置文件：编辑Nginx主配置文件/etc/nginx/nginx.conf或相关虚拟主机配置文件。 添加认证指令：在相应的server块或location块中添加以下指令以启用基本认证： 12345location / &#123; auth_basic &quot;Restricted&quot;; auth_basic_user_file /etc/nginx/passwords; # 其他配置...&#125; auth_basic &quot;Restricted&quot;;定义了认证提示信息。 auth_basic_user_file指定之前创建的密码文件路径。 步骤3：重新加载 保存配置文件更改后，重启Nginx服务以应用新设置： 1nginx -s reload 步骤4：测试访问 尝试访问网站，系统应提示输入用户名和密码。使用在passwords文件中定义的凭据登录，若正确，可正常访问网站。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.esearch.top/tags/Nginx/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"Debian脚本中使用了&>/dev/null，$?总是返回0","date":"2024-09-30T09:33:10.000Z","path":"posts/78eb14d2/","text":"一、问题现象 在CentOS中编写了一段Shell脚本，作用很简单，就是监控nginx的配置文件是否发生了变化，如果发生了变化就自动reload一次，脚本如下： 123456789101112131415161718192021222324#!/bin/bashwhile truedo md5=`md5sum /etc/nginx/conf.d/port-to-domain.conf | awk &#x27;&#123;print $1&#125;&#x27;` grep $&#123;md5&#125; /tmp/md5result &amp;&gt;/dev/null if [ $? -ne 0 ];then echo `date` &#x27;Config File Change&#x27; echo `date` &#x27;Command nginx -t exec&#x27; nginx -t if [ $? -eq 0 ];then echo `date` &#x27;Command nginx -t exec success&#x27; nginx -s reload echo `date` &#x27;Command nginx -s reload exec&#x27; else echo `date` &#x27;Command nginx -t exec failed&#x27; fi echo $&#123;md5&#125; &gt; /tmp/md5result echo `date` &#x27;Change md5result&#x27; else echo `date` &#x27;Config File NoChange&#x27; fi sleep 5done 在CentOS中运行一切正常，但是在Debian中运行异常，具体是grep $&#123;md5&#125; /tmp/md5result &amp;&gt;/dev/null的返回值总是0 Centos执行过程 123456789[root@txy201-51 ~]# sh -x monitor.sh + true++ md5sum /etc/nginx/conf.d/port-to-domain.conf++ awk &#x27;&#123;print $1&#125;&#x27;+ md5=37e9863c68386613dd0ee4b3a5183380+ grep 37e9863c68386613dd0ee4b3a5183380 /tmp/md5result+ &#x27;[&#x27; 1 -ne 0 &#x27;]&#x27; # 正常返回非0值+ echo &#x27;Config File Change&#x27;Config File Change Debian系统执行过程 12345678910root@cd3b9bf29db3:/# sh -x monitor.sh + true+ md5sum /etc/nginx/conf.d/port-to-domain.conf+ awk &#123;print $1&#125;+ md5=bca7fa98ab245fa12a4a70a9b15e8b9a+ + [ 0 -ne 0 ] # 结果返回0，即使/tmp/md5result不存在也返回0+ grep bca7fa98ab245fa12a4a70a9b15e8b9a /tmp/md5result+ date+ echo Mon Sep 30 09:21:43 UTC 2024 Config File NoChange 二、问题排查 我在Debian的命令行手动执行以上命令，均无问题。 12345root@cd3b9bf29db3:/# md5=`md5sum /etc/nginx/conf.d/port-to-domain.conf | awk &#x27;&#123;print $1&#125;&#x27;`root@cd3b9bf29db3:/# grep $&#123;md5&#125; /tmp/md5result &amp;&gt;/dev/nullroot@cd3b9bf29db3:/# echo $?2 # 返回正常root@cd3b9bf29db3:/# 尝试将&amp;&gt;/dev/null删除掉，再测试，发现正常了，不知道是啥原因导致的异常。 12345678root@cd3b9bf29db3:/# sh -x monitor.sh + true+ md5sum /etc/nginx/conf.d/port-to-domain.conf+ awk &#123;print $1&#125;+ md5=bca7fa98ab245fa12a4a70a9b15e8b9a+ grep bca7fa98ab245fa12a4a70a9b15e8b9a /tmp/md5resultgrep: /tmp/md5result: No such file or directory+ [ 2 -ne 0 ] # 返回值正常了 我尝试修改了运行脚本的方式，从sh scritp.sh 修改为bash script.sh，结果成功了 123456789101112131415161718root@cd3b9bf29db3:/# echo &gt; /tmp/md5result # bash 与预期相符root@cd3b9bf29db3:/# bash monitor.sh Mon Sep 30 09:48:11 UTC 2024 Config File ChangeMon Sep 30 09:48:11 UTC 2024 Command nginx -t execnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successfulMon Sep 30 09:48:11 UTC 2024 Command nginx -t exec success2024/09/30 09:48:11 [notice] 592#592: signal process startedMon Sep 30 09:48:11 UTC 2024 Command nginx -s reload execMon Sep 30 09:48:11 UTC 2024 Change md5resultMon Sep 30 09:48:16 UTC 2024 Config File NoChange^Croot@cd3b9bf29db3:/# echo 1 &gt; /tmp/md5result # sh 与预期不相符root@cd3b9bf29db3:/# sh monitor.sh Mon Sep 30 09:48:38 UTC 2024 Config File NoChangeMon Sep 30 09:48:43 UTC 2024 Config File NoChange 三、结论 这个结论是问AI的您遇到的问题很可能是由于sh和bash在处理某些命令或脚本构造时的行为差异所致。在Linux系统中，sh通常指的是POSIX shell，而bash是Bourne Again SHell的简称，它是GNU项目的一个兼容sh的shell程序，提供了许多sh没有的特性和改进。 为啥CentOS可以，Debian不行? 应该是sh的版本等不同造成的。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://www.esearch.top/tags/Shell/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"使用docker安装webssh","date":"2024-09-24T09:31:30.000Z","path":"posts/e0c5f301/","text":"部署webssh，可以实现使用浏览器ssh登录，摆脱工具的限制 部署 docker运行 1docker run -d --log-driver json-file --log-opt max-file=1 --log-opt max-size=100m -p 8032:5032 --restart always --name webssh -e TZ=Asia/Shanghai -e authInfo=用户名:密码 -e savePass=false jrohy/webssh 支持添加的环境变量： 123port: web使用端口, 默认5032savePass: 是否保存密码, 默认trueauthInfo: 开启账号密码登录验证, &#x27;user:pass&#x27;的格式设置 打开网页 nginx反向代理(可选) 1234567891011121314151617181920map $http_upgrade $connection_upgrade &#123; default keep-alive; &#x27;websocket&#x27; upgrade;&#125;server &#123; listen 80; client_max_body_size 1024m; server_name webssh.域名.top; location / &#123; proxy_set_header Host $host; proxy_pass http://0.0.0.0:8032; # 转发 proxy_set_header X-Real-IP $remote_addr; #获取客户端真实IP proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; add_header Access-Control-Allow-Origin *; &#125;&#125;","tags":[{"name":"工具","slug":"工具","permalink":"https://www.esearch.top/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Docker","slug":"Docker","permalink":"https://www.esearch.top/tags/Docker/"}],"categories":[{"name":"工具类","slug":"工具类","permalink":"https://www.esearch.top/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"title":"gitpage 套上 cloudflare后显示过多重定向问题解决","date":"2024-09-17T08:07:35.000Z","path":"posts/6c7d376/","text":"一、现象 在cloudflare设置好dns之后，gitpage页面无法打开，显示将您重定向的次数过多 二、解决办法 在cloudflare的SSL/TLS &gt; 概述中，将SSL/TLS加密修改为灵活即可。","tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.esearch.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.esearch.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"OpenEuler 安装MySql","date":"2024-09-10T01:22:10.000Z","path":"posts/b5a91e2c/","text":"安装mysql 1yum install mysql-server -y 初始化 1mysqld --initialize --console 目录授权 1chown -R mysql:mysql /var/lib/mysql/ 注意，如果在/etc/my.cnf.d/my.cnf中修改了目录路径，需要对相关路径进行权限修改。 设置登录密码 修改配置 123vi /etc/my.cnf#在mysqld模块下添加skip-grant-tables 重启服务 1systemctl restart mysqld 进入数据库 12mysql -u root -p# 在提示密码时直接按回车 在数据库中刷新权限 12mysql&gt; flush privileges;Query OK, 0 rows affected (0.05 sec) 修改密码 12mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;newpassword&#x27;;Query OK, 0 rows affected (0.01 sec) 删除配置 123vi /etc/my.cnf#在mysqld模块下删除skip-grant-tables 重启服务就可以使用密码登录了 1systemctl restart mysqld","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"},{"name":"Database","slug":"Database","permalink":"https://www.esearch.top/tags/Database/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"openEuler开启kdump失败","date":"2024-06-24T07:23:00.000Z","path":"posts/1c033694/","text":"一、现象 openEuler启动kdump失败，显示No memory reserved for crash kernel 12345678910111213[root@kvm-hkcloud01 ~]# systemctl status kdump kdump.service - Crash recovery kernel arming Loaded: loaded (/usr/lib/systemd/system/kdump.service; enabled; vendor preset: enabled) Active: failed (Result: exit-code) since Mon 2024-06-24 14:50:48 CST; 26min ago Process: 1004 ExecStart=/usr/bin/kdumpctl start (code=exited, status=1/FAILURE) Main PID: 1004 (code=exited, status=1/FAILURE)Jun 24 14:50:47 kvm-hkcloud01 systemd[1]: Starting Crash recovery kernel arming...Jun 24 14:50:48 kvm-hkcloud01 kdumpctl[1015]: No memory reserved for crash kernelJun 24 14:50:48 kvm-hkcloud01 kdumpctl[1015]: Starting kdump: [FAILED]Jun 24 14:50:48 kvm-hkcloud01 systemd[1]: kdump.service: Main process exited, code=exited, status=1/FAILUREJun 24 14:50:48 kvm-hkcloud01 systemd[1]: kdump.service: Failed with result &#x27;exit-code&#x27;.Jun 24 14:50:48 kvm-hkcloud01 systemd[1]: Failed to start Crash recovery kernel arming. 二、问题分析 根据提示来看，应该是申请不到内存导致的，但从free的结果来看，是可以满足kdump的要求的 资源剩余700M+ 12345[root@kvm-hkcloud01 ~]# free -h total used free shared buff/cache availableMem: 967Mi 89Mi 442Mi 23Mi 436Mi 715MiSwap: 0B 0B 0B[root@kvm-hkcloud01 ~]# kdump的需求是512M 123[root@kvm-hkcloud01 ~]# cat /proc/cmdlineBOOT_IMAGE=/boot/vmlinuz-5.10.0-136.12.0.86.oe2203sp1.x86_64 root=UUID=d372d015-87b7-44ed-9860-33c9d47eedb6 ro cgroup_disable=files apparmor=0 crashkernel=512M[root@kvm-hkcloud01 ~]# 为什么会分配不到资源呢？难道是启动期间资源不足导致？ 接下来我将crash的内存修改为128M，发现可以启动成功。 123456789101112131415161718192021222324252627282930313233343536373839404142# 查看当前配置[root@kvm-hkcloud01 ~]# cat /etc/default/grubGRUB_TIMEOUT=5GRUB_DISTRIBUTOR=&quot;$(sed &#x27;s, release .*$,,g&#x27; /etc/system-release)&quot;GRUB_DEFAULT=savedGRUB_DISABLE_SUBMENU=trueGRUB_TERMINAL_OUTPUT=&quot;console&quot;GRUB_CMDLINE_LINUX=&quot;cgroup_disable=files apparmor=0 crashkernel=512M&quot;GRUB_DISABLE_RECOVERY=&quot;true&quot;# 修改为128[root@kvm-hkcloud01 ~]# sed -i &#x27;s/512/128/g&#x27; /etc/default/grub# 重新生成grub.cfg[root@kvm-hkcloud01 ~]# grub2-mkconfig -o /boot/grub2/grub.cfgGenerating grub configuration file ...Found linux image: /boot/vmlinuz-5.10.0-136.12.0.86.oe2203sp1.x86_64Found initrd image: /boot/initramfs-5.10.0-136.12.0.86.oe2203sp1.x86_64.imgFound linux image: /boot/vmlinuz-0-rescue-7c27015c30d4409fb116e3795e6126c4Found initrd image: /boot/initramfs-0-rescue-7c27015c30d4409fb116e3795e6126c4.imgAdding boot menu entry for UEFI Firmware Settings ...done# 重启主机[root@kvm-hkcloud01 ~]# reboot# 查看服务[root@kvm-hkcloud01 ~]# systemctl status kdump● kdump.service - Crash recovery kernel arming Loaded: loaded (/usr/lib/systemd/system/kdump.service; enabled; vendor preset: enabled) Active: active (exited) since Wed 2024-06-26 10:25:09 CST; 1min 12s ago Process: 1002 ExecStart=/usr/bin/kdumpctl start (code=exited, status=0/SUCCESS) Main PID: 1002 (code=exited, status=0/SUCCESS)Jun 26 10:25:03 kvm-hkcloud01 systemd[1]: Starting Crash recovery kernel arming...Jun 26 10:25:09 kvm-hkcloud01 kdumpctl[1009]: kexec: loaded kdump kernelJun 26 10:25:09 kvm-hkcloud01 kdumpctl[1009]: Starting kdump: [OK]Jun 26 10:25:09 kvm-hkcloud01 systemd[1]: Finished Crash recovery kernel arming.[root@kvm-hkcloud01 ~]## 查看内存，可以看到内存的总量比之前少了128M，说明128M的内存已经分配给crash了。[root@kvm-hkcloud01 ~]# free -h total used free shared buff/cache availableMem: 839Mi 85Mi 559Mi 6.2Mi 195Mi 623MiSwap: 0B 0B 0B[root@kvm-hkcloud01 ~]# 不能分配太少的内存，如果内存太少，会有 Could not find a free area of memory of 0x1ddd000 bytes...错误，可以通过 makedumpfile --mem-usage /proc/kcore来估算需要多少内存。 结论 虚拟机内存少，而crash设置的内存比较多，会出现因资源不足没办法给crash分配内存的情况，导致kdump启动失败，可以通过修改crash内存参数来解决。","tags":[{"name":"openEuler","slug":"openEuler","permalink":"https://www.esearch.top/tags/openEuler/"},{"name":"kdump","slug":"kdump","permalink":"https://www.esearch.top/tags/kdump/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"Linux重装系统后恢复LVM","date":"2024-06-21T09:16:37.000Z","path":"posts/1208ed6f/","text":"最近重装了操作系统，仅格式化了操作系统盘，数据盘没有动，因为数据盘之前使用lvm进行管理的，不能直接挂在，要先恢复lvm信息才能挂载。 恢复的前提是要知道vg的名称！！！ 步骤如下： 扫描和识别pv信息 123[root@kvm-hkcloud01 ~]# pvscan PV /dev/vdb VG vg_data lvm2 [&lt;30.00 GiB / 1020.00 MiB free] Total: 1 [&lt;30.00 GiB] / in use: 1 [&lt;30.00 GiB] / in no VG: 0 [0 ] 激活vg（前提是要知道vg的名称） 12[root@kvm-hkcloud01 ~]# vgchange -ay vg_data 1 logical volume(s) in volume group &quot;vg_data&quot; now active 查看是否有lv数据 12345678910111213141516171819[root@kvm-hkcloud01 ~]# lvdisplay --- Logical volume --- LV Path /dev/vg_data/lv_data LV Name lv_data VG Name vg_data LV UUID JJOdQt-2l5h-fEHJ-MkIo-bwG3-G3YV-mfjz72 LV Write Access read/write LV Creation host, time kvm-hkcloud01.local, 2024-02-23 11:41:13 +0800 LV Status available # open 0 LV Size 29.00 GiB Current LE 7424 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 252:0[root@kvm-hkcloud01 ~]# 挂载 12345678910[root@kvm-hkcloud01 ~]# mount /dev/mapper/vg_data-lv_data /data[root@kvm-hkcloud01 ~]# df -hFilesystem Size Used Avail Use% Mounted ondevtmpfs 4.0M 0 4.0M 0% /devtmpfs 484M 0 484M 0% /dev/shmtmpfs 194M 5.4M 189M 3% /runtmpfs 4.0M 0 4.0M 0% /sys/fs/cgroup/dev/vda1 50G 1.8G 46G 4% /tmpfs 484M 0 484M 0% /tmp/dev/mapper/vg_data-lv_data 29G 3.4G 26G 12% /data 参考资料","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"},{"name":"文件系统","slug":"文件系统","permalink":"https://www.esearch.top/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"Linux中sysrq-trigger的妙用","date":"2024-06-21T08:13:01.000Z","path":"posts/c0f21a4/","text":"sysrq被称为魔术组合键，只要内核没有完全锁住，不管内核在做什么事情，使用这些组合键都可以搜集包括系统内存使用、CPU任务处理、进程运行状态等系统运行信息。 注意：信息的输出都在/var/log/message下 Linux如何模拟崩溃？如何强制关机？这时候就可以使用到本文提到的/proc/sysrq-trigger文件了。 故意让系统崩溃，注意这不是重启，崩溃后只能从进行硬重启才能重连上系统。（产生空指针paincz事件，触发kdump，收集vmcore，会在/var/crash目录生成） 1echo &quot;c&quot; &gt; /proc/sysrq-trigger 立即重新启动计算机 1echo &quot;b&quot; &gt; /proc/sysrq-trigger 立即关闭计算机 1echo &quot;o&quot; &gt; /proc/sysrq-trigger 导出内存分配的信息 （可以用/var/log/message 查看） 1echo &quot;m&quot; &gt; /proc/sysrq-trigger 导出当前CPU寄存器信息和标志位的信息 1echo &quot;p&quot; &gt; /proc/sysrq-trigger 导出线程状态信息 1echo &quot;t&quot; &gt; /proc/sysrq-trigger 故意让系统溃 1echo &quot;c&quot; &gt; /proc/sysrq-trigger 立即重新挂载所有的文件系统 1echo &quot;s&quot; &gt; /proc/sysrq-trigger 立即重新挂载所有的文件系统为只读 1echo &quot;u&quot; &gt; /proc/sysrq-trigger 为了安全起见，在红帽企业版Linux里面，默认SysRq组合键是关闭的。 打开这个功能，运行： 1echo 1 &gt; /proc/sys/kernel/sysrq 关闭这个功能： 1echo 0 &gt; /proc/sys/kernel/sysrq 如果想让此功能一直生效，在/etc/sysctl.conf里面设置kernel.sysrq的值为1. 重新启动以后，此功能将会自动打开。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"Jquery禁用按钮，防止重复提交","date":"2024-06-21T07:58:07.000Z","path":"posts/17c655b1/","text":"使用对象.prop(&quot;disabled&quot;,true)可以进行禁用，对象.prop(&quot;disabled&quot;,false)取消禁用。 html代码如下 1234567&lt;form id=&quot;editEventForm&quot; novalidate=&quot;novalidate&quot;&gt;..... &lt;div class=&quot;card-footer&quot;&gt; &lt;a href=&quot;javascript:history.go(-1);&quot; class=&quot;btn btn-success float-right&quot;&gt;&lt;/i&gt; 返回&lt;/a&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary float-right&quot; style=&quot;margin-right:5px;&quot;&gt;提交&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; js代码 12345&lt;script&gt; $(&quot;#editEventForm button[type=&#x27;submit&#x27;]&quot;).click(function(e)&#123; $(&quot;#editEventForm button[type=&#x27;submit&#x27;]&quot;).prop(&quot;disabled&quot;,true) &#125;)&lt;/script&gt; 注意：如果您的提交按钮设置了ID，可以使用$(“#ID名称”).prop(“disabled”,true)来操作，这样就不用写这么长了。 可以在提交成功或失败后，执行取消禁用 1$(&quot;#editEventForm button[type=&#x27;submit&#x27;]&quot;).prop(&quot;disabled&quot;,false) 参考资料","tags":[{"name":"Jquery","slug":"Jquery","permalink":"https://www.esearch.top/tags/Jquery/"}],"categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://www.esearch.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"systemd怎么查看开机自启动服务","date":"2024-06-21T03:31:50.000Z","path":"posts/614dd6d8/","text":"在CentOS 7及更高的版本中，使用chkconfig命令查看开机自启动信息时，发现只有几个服务被SysV管理的服务，没有包括systemd管理的服务。 12345678910111213[root@kvm-hkcloud01 var]# chkconfig --listNote: This output shows SysV services only and does not include native systemd services. SysV configuration data might be overridden by native systemd configuration. If you want to list systemd services use &#x27;systemctl list-unit-files&#x27;. To see services enabled on particular target use &#x27;systemctl list-dependencies [target]&#x27;.netconsole 0:off 1:off 2:off 3:off 4:off 5:off 6:offnetwork 0:off 1:off 2:on 3:on 4:on 5:on 6:off[root@kvm-hkcloud01 var]# 如果需要查看被systemd管理的服务，可以使用以下命令进行查询。 1[root@kvm-hkcloud01 var]# systemctl list-unit-files 更多systemd内容，可参考https://ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"Linux文件的ACL","date":"2024-06-20T07:26:54.000Z","path":"posts/de677c90/","text":"在Linux中，一般使用chmod命令对属主、用户组、其它用户为类别对文件权限进行控制，这种方式较为粗略，但也能满足日常需求。在一些特殊的场景中，如只允许某些用户能访问文件的场景，如果使用chmod命令进行配置，一般是将这部分用户加入到组中，然后配置组的权限。 在Linux中，还提供了一种精细化的文件权限控制方式，那就是ACL（Access Control List） 在没有ACL技术之前,Linux系统对文件的权限控制仅可划分文件的属主、用户组、其他用户三类,随着技术的发展,传统的文件权限控制已经无法适应复杂场景下的权限控制需求,比如说一个部门(即一个用户组group)存在有多名员工(即用户,user01、user02…),针对于部门内不同职责的员工,会为其赋予不同的权限,如为user01赋予可读写权限,为user02赋予只读权限,不为user03赋予任何权限,此时由于这些员工属于同一部门,就无法为这些不同的员工进行权限的细化。为此ACL(Access Control List)访问控制列表技术应运而生,使用ACL权限控制可以提供常见权限(如rwx、ugo)权限之外的权限设,置,可以针对单一用户或组来设置特定的权限。 使用ACL必须要有文件系统的支持，目前ext3/ext4/xfs/zfs都支持文件ACL。 相关命令 setfacl：设置文件的acl getfacl：获取文件的acl chacl：更改文件或目录的ACL 操作实验 用户权限配置 user01创建文件并配置600权限 1234567891011[root@txy201-51 data]# su user01[user01@txy201-51 data]$ echo 51yunwei.top &gt; acltest[user01@txy201-51 data]$ chmod 600 acltest[user01@txy201-51 data]$ getfacl acltest# file: acltest# owner: user01# group: user01user::rw-group::---other::--- 测试user02有没有访问权限（无） 123[root@txy201-51 data]# su user02[user02@txy201-51 data]$ cat acltestcat: acltest: 权限不够 使用setfacl给user02配置权限 12345678910[user01@txy201-51 data]$ setfacl -m user02:r acltest[user01@txy201-51 data]$ getfacl acltest# file: acltest# owner: user01# group: user01user::rw-user:user02:r--group::---mask::r--other::--- user02测试是否能读（可以）、写文件（不可以） 12345[root@txy201-51 data]# su user02[user02@txy201-51 data]$ cat acltest51yunwei.top[user02@txy201-51 data]$ echo www.51yunwei.top &gt;&gt; acltestbash: acltest: 权限不够 修改user02的权限为读写 123456[root@txy201-51 data]# setfacl -m user02:rw acltest[root@txy201-51 data]# su user02[user02@txy201-51 data]$ echo www.51yunwei.top &gt;&gt; acltest[user02@txy201-51 data]$ cat acltest51yunwei.topwww.51yunwei.top 删除权限 123456789[root@txy201-51 data]# setfacl -x user02 acltest[root@txy201-51 data]# getfacl acltest# file: acltest# owner: user01# group: user01user::rw-group::---mask::r--other::--- 组权限 setfacl默认对用户acl进行管理，如果要为组设置acl，只需要加上一个组的标识g:即可。 当前user03没有访问权限 12345[root@txy201-51 data]# id user03uid=1005(user03) gid=1006(user03) 组=1006(user03),1004(user01)[root@txy201-51 data]# su user03[user03@txy201-51 data]$ cat acltestcat: acltest: 权限不够 给user01组设置权限后，user03就能访问文件了（user03也在user01组） 12345[root@txy201-51 data]# setfacl -m g:user01:r acltest[root@txy201-51 data]# su user03[user03@txy201-51 data]$ cat acltest51yunwei.topwww.51yunwei.top 系统文件权限的备份与恢复 在运维过程中，最怕误操作将全局的文件权限给修改了，比如执行了chmod 777 -R /或chown -R user01:user01 /，那如果真的遇到了这种情况我们应该怎么做呢？在日常运维中，我们可以把系统权限信息进行备份，在必要时进行恢复。 备份文件权限 1getfacl -p &gt; 备份文件 恢复文件权限 1setfacl --restore=备份的文件 实战篇 实验目录/tmp/data，文件结构如下 123456789101112[root@txy201-51 data]# ls -lR.:总用量 8-rw-r-----+ 1 user01 user01 30 6月 20 16:13 acltestdrwxr-xr-x 2 root root 4096 6月 20 16:30 yunwei./yunwei:总用量 0-rw-r--r-- 1 root root 0 6月 20 16:30 51yunwei-rw-r--r-- 1 root root 0 6月 20 16:30 top-rw-r--r-- 1 root root 0 6月 20 16:30 www[root@txy201-51 data]# 将目录的权限备份到tmp_data_acl.bak下 1[root@txy201-51 data]# getfacl -R -p /tmp/data &gt; tmp_data_acl.bak 模拟误操作，修改目录下的所有权限和属主 123456789101112131415[root@txy201-51 data]# chown user01:user01 -R /tmp/data[root@txy201-51 data]# chmod 400 -R /tmp/data[root@txy201-51 data]# ls -lR.:总用量 12-r--------+ 1 user01 user01 30 6月 20 16:13 acltest-r-------- 1 user01 user01 670 6月 20 17:24 tmp_data_acl.bakdr-------- 2 user01 user01 4096 6月 20 16:30 yunwei./yunwei:总用量 0-r-------- 1 user01 user01 0 6月 20 16:30 51yunwei-r-------- 1 user01 user01 0 6月 20 16:30 top-r-------- 1 user01 user01 0 6月 20 16:30 www[root@txy201-51 data]# 恢复权限，可以看到权限已恢复正常。 1234567891011121314[root@txy201-51 data]# setfacl --restore=tmp_data_acl.bak[root@txy201-51 data]# ls -lR.:总用量 12-rw-rw----+ 1 user01 user01 30 6月 20 16:13 acltest-rw-r--r-- 1 root root 670 6月 20 17:24 tmp_data_acl.bakdrwxr-xr-x 2 root root 4096 6月 20 16:30 yunwei./yunwei:总用量 0-rw-r--r-- 1 root root 0 6月 20 16:30 51yunwei-rw-r--r-- 1 root root 0 6月 20 16:30 top-rw-r--r-- 1 root root 0 6月 20 16:30 www[root@txy201-51 data]# 如果没有提前备份的话，可以同其它相同系统做一次备份，将文件拷贝过来做恢复，对于没在备份中的文件，权限不会被修改。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"},{"name":"权限","slug":"权限","permalink":"https://www.esearch.top/tags/%E6%9D%83%E9%99%90/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"Linux中的用户ID会不会重复？","date":"2024-06-18T03:13:16.000Z","path":"posts/a0e0543a/","text":"UID指的是用户的ID(User ID)，一个用户的UID标识一个给定用户，UID是用户的唯一标识符，通过UID可以区分不同的用户类别，比如UID为0的是超级用户，UID为1000-600000之间的是普通用户，而UID为1-999之间的是虚拟用户。 超级用户：也称为root用户，UID为0，拥有系统的完全控制权限，可以进行修改、删除文件等操作。 普通用户：也成为一般用户，UID为1000-60000之间，可以对自己目录下的文件进行访问和修改，也可以对经过授权的文件进行访问。 虚拟用户：也称为系统用户，UID为1-999之间，不提供密码登录系统，它们的存在主要是为了方便系统的管理。 Linux中的用户ID会不会重复？会，可以人为将多个不用户的ID配置为重复的ID。 用户在登录系统时，是通过UID来区分用户，而不是通过用户名来区分 实验步骤： 1、创建一个UID为1000的用户user02，再创建一个相同id的user01，通过id命令，发现两个用户都显示为user02 123456[root@kvm-hkcloud01 ~]# useradd -u 1000 user02[root@kvm-hkcloud01 ~]# useradd -u 1000 -o user01[root@kvm-hkcloud01 ~]# id user01uid=1000(user02) gid=1002(user02) groups=1002(user02)[root@kvm-hkcloud01 ~]# id user02uid=1000(user02) gid=1002(user02) groups=1002(user02) 2、切换到user01下，发现名称还是user02，但是组信息变为了user01的 12345[root@kvm-hkcloud01 ~]# su - user01Last login: Tue Jun 18 11:35:27 CST 2024 on pts/0[user02@kvm-hkcloud01 ~]$ iduid=1000(user02) gid=1003(user01) groups=1003(user01)[user02@kvm-hkcloud01 ~]$ 3、当user02的uid发生改变时，再查看user01的信息，因为没有重复的id的情况下，用户名就能正常的显示user01了 12345[root@kvm-hkcloud01 ~]# usermod -u 1001 user02[root@kvm-hkcloud01 ~]# id user02uid=1001(user02) gid=1002(user02) groups=1002(user02)[root@kvm-hkcloud01 ~]# id user01uid=1000(user01) gid=1003(user01) groups=1003(user01) 4、当我再将user02的uid修改为1000的时候，再查看user01的信息，发现user01的用户名又显示为user02了 12345[root@kvm-hkcloud01 ~]# usermod -u 1000 -o user02[root@kvm-hkcloud01 ~]# id user02uid=1000(user02) gid=1002(user02) groups=1002(user02)[root@kvm-hkcloud01 ~]# id user01uid=1000(user02) gid=1002(user02) groups=1002(user02) 那么，当UID重复的时候，是谁决定了用哪个用户名作为显示呢？ 想一想，哪个文件记录了UID信息？没错,是/etc/passwd当我将user01和user02的行进行调转之后（user01）在前，使用id查看的时候，显示的用户名就是user01了 123456789101112131415161718# 修改前[root@kvm-hkcloud01 ~]# tail -n 2 /etc/passwduser02:x:1000:1002::/home/user02:/bin/bashuser01:x:1000:1003::/home/user01:/bin/bash[root@kvm-hkcloud01 ~]# id user01uid=1000(user02) gid=1002(user02) groups=1002(user02)[root@kvm-hkcloud01 ~]# id user02uid=1000(user02) gid=1002(user02) groups=1002(user02)[root@kvm-hkcloud01 ~]# vi /etc/passwd# 修改后[root@kvm-hkcloud01 ~]# tail -n 2 /etc/passwduser01:x:1000:1003::/home/user01:/bin/bashuser02:x:1000:1002::/home/user02:/bin/bash[root@kvm-hkcloud01 ~]# id user01uid=1000(user01) gid=1003(user01) groups=1003(user01)[root@kvm-hkcloud01 ~]# id user02uid=1000(user01) gid=1003(user01) groups=1003(user01)","tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://www.esearch.top/tags/Linux%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"怎么判断多台虚拟机上的磁盘是不是同一块磁盘呢？","date":"2024-05-31T08:30:15.000Z","path":"posts/b6ae4c2c/","text":"在虚拟化环境上，有普通磁盘和共享磁盘，有时候进行扩容后，多台虚拟机上的磁盘大小一样，那怎么判断某个盘是不是共享磁盘呢？这时候我们可以使用blkid命令来查看。 命令输出结果如下，如果多台虚拟机输出的uuid是一样的，那这个磁盘就是共享磁盘了。 12[root@txy201-51 tmp]# blkid /dev/vda1/dev/vda1: UUID=&quot;4b499d76-769a-40a0-93dc-4a31a59add28&quot; TYPE=&quot;ext4&quot;","tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://www.esearch.top/tags/Linux%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"Linux中的软链接和硬链接","date":"2024-05-31T07:48:29.000Z","path":"posts/83a68e5f/","text":"在Linux中，可以使ln命令创建链接文件，默认是硬链接，如果加-s参数，就是创建软连接。 软链接：和Windows中的快捷方式差不多，这个链接文件指向源文件，和源文件不同，源文件被删除时，软链接文件无法访问。 硬链接：硬链接更像是源文件的副本，这两个文件指向了相同的inode，源文件被删除时，inode的硬链接数不为0，数据不会删除，此时访问硬链接文件正常。 一、软链接和硬链接文件信息 1、创建链接文件 1234[root@txy201-51 tmp]# echo 123 &gt; passwd[root@txy201-51 tmp]# ln passwd link_h_passwd[root@txy201-51 tmp]# ln -s passwd link_s_passwd 2、查看源文件信息，inode为51380 1234567891011[root@txy201-51 tmp]# stat passwd 文件：&quot;passwd&quot; 大小：16 块：8 IO 块：4096 普通文件设备：fd01h/64769d Inode：51380 硬链接：2权限：(0644/-rw-r--r--) Uid：( 0/ root) Gid：( 0/ root)最近访问：2024-05-31 15:45:22.174997597 +0800最近更改：2024-05-31 15:45:21.844997227 +0800最近改动：2024-05-31 15:45:21.844997227 +0800创建时间：-[root@txy201-51 tmp]# 3、查看硬链接文件，inode也是51380，和源文件指向了相同的inode，而且文件属性为普通文件，而不是链接文件。 12345678910[root@txy201-51 tmp]# stat link_h_passwd 文件：&quot;link_h_passwd&quot; 大小：16 块：8 IO 块：4096 普通文件设备：fd01h/64769d Inode：51380 硬链接：2权限：(0644/-rw-r--r--) Uid：( 0/ root) Gid：( 0/ root)最近访问：2024-05-31 15:45:22.174997597 +0800最近更改：2024-05-31 15:45:21.844997227 +0800最近改动：2024-05-31 15:45:21.844997227 +0800创建时间：-[root@txy201-51 tmp]# 4、再看看软连接的状态,文件的大小、指向的inode和源文件不同，文件类型为符号链接 12345678910[root@txy201-51 tmp]# stat link_s_passwd 文件：&quot;link_s_passwd&quot; -&gt; &quot;passwd&quot; 大小：6 块：0 IO 块：4096 符号链接设备：fd01h/64769d Inode：51379 硬链接：1权限：(0777/lrwxrwxrwx) Uid：( 0/ root) Gid：( 0/ root)最近访问：2024-05-31 15:38:40.578545132 +0800最近更改：2024-05-31 15:38:39.634544066 +0800最近改动：2024-05-31 15:38:39.634544066 +0800创建时间：-[root@txy201-51 tmp]# 二、修改源文件，链接文件的变化 1、修改源源文件，可以看到软链接和硬链接文件的内容也随之改变了 1234567[root@txy201-51 tmp]# echo 456 &gt; passwd[root@txy201-51 tmp]# cat link_s_passwd456[root@txy201-51 tmp]# cat link_h_passwd456[root@txy201-51 tmp]# 2、修改软连接文件，可以看到源文件和硬链接文件也都发生了变化，因为软连接就是指向源文件的，可以理解为对源文件的修改。 123456[root@txy201-51 tmp]# echo 789 &gt; link_s_passwd[root@txy201-51 tmp]# cat passwd789[root@txy201-51 tmp]# cat link_h_passwd789[root@txy201-51 tmp]# 3、修改硬链接文件，可以看到软链接和源文件的数据也发生了变化，因为修改硬链接，实际上修改的是inode块的数据，源文件指向的也是这个数据块，所以内容也会发生变化。 123456[root@txy201-51 tmp]# echo &#x27;abc&#x27; &gt; link_h_passwd[root@txy201-51 tmp]# cat passwdabc[root@txy201-51 tmp]# cat link_s_passwdabc[root@txy201-51 tmp]# 三、删除源文件对链接文件的影响 1、删除源文件，软链接文件无法访问，硬链接文件访问正常 123456[root@txy201-51 tmp]# rm -f passwd[root@txy201-51 tmp]# cat link_s_passwdcat: link_s_passwd: 没有那个文件或目录[root@txy201-51 tmp]# cat link_h_passwdabc[root@txy201-51 tmp]# 2、如果再创建一个和源文件一样的文件，可以看到软链接文件可以正常访问了，但是硬链接的数据和源文件不一致，你知道这是为什么吗？ 因为再次创建‘源’文件之后，‘源’文件的inode发生了变化，所以数据肯定不一致。而软连接是对路径的链接，只要这个路径在，就可以访问。 123456[root@txy201-51 tmp]# echo 123 &gt; passwd[root@txy201-51 tmp]# cat link_h_passwdabc[root@txy201-51 tmp]# cat link_s_passwd123[root@txy201-51 tmp]#","tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://www.esearch.top/tags/Linux%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"openEuler中奇怪的网络管理服务","date":"2024-05-30T09:11:31.000Z","path":"posts/4cf37030/","text":"openEuler中的网络服务 管理网络服务 openEuler没有network服务，当我修改了网卡配置文件之后，使用以下命令进行重启，报错Failed to restart network.service: Unit network.service not found. 123[root@localhost sshuser]# systemctl restart networkFailed to restart network.service: Unit network.service not found.[root@localhost sshuser]# 经过查询才知道，EulerOS没有network服务，而是使用NetworkManager管理网络服务，所以直接重启这个服务即可。 1[root@localhost sshuser]# systemctl restart NetworkManager 让我感觉到奇怪的点是，在系统中是可以查到network服务的，但用systemctl和service命令却管理不了它。 1234567[root@localhost sshuser]# systemctl | grep network sys-devices-pci0000:00-0000:00:12.0-virtio1-net-ens18.device loaded active plugged Virtio network device sys-subsystem-net-devices-ens18.device loaded active plugged Virtio network device network-online.target loaded active active Network is Online network-pre.target loaded active active Preparation for Network network.target loaded active active Network[root@localhost sshuser]# 修改网卡配置 第二个奇怪的点是，修改网卡配置文件，掩码只能使用PEREFIX来表示，不能使用NETMASK，不然IP地址修改不成功了 123IPADDR=192.168.3.138PREFIX=24GATEWAY=192.168.3.1 查看IP的命令 在openEuler中，除了可以使用ip add命令查看地址外，还可以使用nmcli命令查看，默认自带了这两个命令。 123456789101112131415161718192021222324252627282930313233343536[root@localhost network-scripts]# nmcli dev showGENERAL.DEVICE: ens18GENERAL.TYPE: ethernetGENERAL.HWADDR: 8E:F7:F5:E9:2A:78GENERAL.MTU: 1500GENERAL.STATE: 100 (connected)GENERAL.CONNECTION: ens18GENERAL.CON-PATH: /org/freedesktop/NetworkManager/ActiveConnection/1WIRED-PROPERTIES.CARRIER: onIP4.ADDRESS[1]: 192.168.3.138/24IP4.GATEWAY: 192.168.3.1IP4.ROUTE[1]: dst = 0.0.0.0/0, nh = 192.168.3.1, mt = 100IP4.ROUTE[2]: dst = 192.168.3.0/24, nh = 0.0.0.0, mt = 100IP6.ADDRESS[1]: 2409:8a55:8f2:xxa4:8cf7:fxxf:fxe9:xxx/64IP6.ADDRESS[2]: 2409:8a55:8f2:xxa4:d4bb:e68f:cx3x:x/128IP6.ADDRESS[3]: fe80::8cf7:f5ff:fee9:2a78/64IP6.GATEWAY: fe80::1IP6.ROUTE[1]: dst = 2409:8a55:8f2:bca4::/64, nh = ::, mt = 100IP6.ROUTE[2]: dst = ::/0, nh = fe80::1, mt = 100IP6.ROUTE[3]: dst = 2409:8a55:8f2:bca4:d4bb:e68f:cb34:3/128, nh = ::, mt = 100IP6.ROUTE[4]: dst = fe80::/64, nh = ::, mt = 100IP6.DNS[1]: fe80::1GENERAL.DEVICE: loGENERAL.TYPE: loopbackGENERAL.HWADDR: 00:00:00:00:00:00GENERAL.MTU: 65536GENERAL.STATE: 10 (unmanaged)GENERAL.CONNECTION: --GENERAL.CON-PATH: --IP4.ADDRESS[1]: 127.0.0.1/8IP4.GATEWAY: --IP6.ADDRESS[1]: ::1/128IP6.GATEWAY: --IP6.ROUTE[1]: dst = ::1/128, nh = ::, mt = 256[root@localhost network-scripts]#","tags":[{"name":"openEuler","slug":"openEuler","permalink":"https://www.esearch.top/tags/openEuler/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"给hexo主题添加代码块复制功能","date":"2024-05-29T07:32:02.000Z","path":"posts/6646bad2/","text":"适用于所有的Hexo主题 创建clipboard_use.js 在themes/xxx/source/js 目录下，创建clipboard_use.js，添加内容如下 12345678910111213141516171819202122232425262728293031323334353637$(&quot;.highlight&quot;).wrap(&quot;&lt;div class=&#x27;code-wrapper&#x27; style=&#x27;position:relative&#x27;&gt;&lt;/div&gt;&quot;);/*页面载入完成后，创建复制按钮*/!function (e, t, a) &#123; /* code */ var initCopyCode = function () &#123; var copyHtml = &#x27;&#x27;; copyHtml += &#x27;&lt;button class=&quot;btn-copy&quot; data-clipboard-snippet=&quot;&quot;&gt;&#x27;; copyHtml += &#x27; &lt;i class=&quot;fa fa-clipboard&quot;&gt;&lt;/i&gt;&lt;span&gt;复制&lt;/span&gt;&#x27;; copyHtml += &#x27;&lt;/button&gt;&#x27;; /* $(&quot;.highlight .code&quot;).before(copyHtml); */ $(&quot;.code-wrapper .highlight table&quot;).before(copyHtml); var clipboard = new ClipboardJS(&#x27;.btn-copy&#x27;, &#123; target: function (trigger) &#123; var tablee = trigger.nextElementSibling; &lt;!-- return trigger.nextElementSibling; --&gt; return tablee.firstElementChild.firstElementChild.firstElementChild.nextElementSibling; &#125; &#125;); clipboard.on(&#x27;success&#x27;, function (e) &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制成功&lt;/span&gt;&quot; setTimeout(function () &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制&lt;/span&gt;&quot; &#125;, 1000) e.clearSelection(); &#125;); clipboard.on(&#x27;error&#x27;, function (e) &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制失败&lt;/span&gt;&quot; setTimeout(function () &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制&lt;/span&gt;&quot; &#125;, 1000) e.clearSelection(); &#125;); &#125; initCopyCode();&#125;(window, document); 添加CSS 在theme/xxx/source/css/style.css样式中添加如下代码： 12345678910111213141516171819202122232425262728293031323334/* 代码块复制按钮 */.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px&#125;.code-wrapper:hover .btn-copy &#123; opacity: 1;&#125; 引入font-awesome 按钮上面添加了一个小图标美化，需要引入font-awesome. 在themes\\xxx\\layout\\_partial\\head.ejs或themes\\xxx\\layout\\_common\\head.ejs中的&lt;/head&gt;之前添加 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&quot;&gt; 引用其他js 在themes\\xxx\\layout\\layout.ejs文件中的&lt;/body&gt;标签前也就是body标签之间的最后加入如下代码,这里是将clipboard.min.js和clipboard-use.js保存到CDN上，通过远程引用 或者将他们直接下载到本地直接引用也可 1234&lt;!-- 代码块复制功能 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/clipboard_use.js&quot;&gt;&lt;/script&gt; 部署 最后就可以使用hexo提交就行啦 1hexo g -d 参考资料 为Hexo主题增加代码块复制功能","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.esearch.top/tags/hexo/"}],"categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.esearch.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"当前博客使用主题及部署方式","date":"2024-05-29T03:39:06.000Z","path":"posts/6646bad1/","text":"当前使用的主题是Wikitten 部署文档链接如下： 1https://github.com/zthxxx/hexo-theme-Wikitten/blob/master/README_zh-CN.md","tags":[],"categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.esearch.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"清除模态框form的内容","date":"2024-04-19T00:38:14.000Z","path":"posts/6646bac7/","text":"在模态框提交数据后，页面不刷新的情况下，再次点击模态框，上次输入的内容还保留着，可以通过下面的方式清除模态框内容 12345678// 在ajax返回成功时可以执行$(&#x27;.modal-body&#x27;).find(&#x27;form&#x27;).trigger(&#x27;reset&#x27;);// 如果在用户点击关闭时也要执行，可以在show.bs.modal事件里设置 $(&#x27;#updatemodal&#x27;).on(&#x27;show.bs.modal&#x27;, function (event) &#123; $(&#x27;.modal-body&#x27;).find(&#x27;form&#x27;).trigger(&#x27;reset&#x27;); // 其他内容 &#125;)","tags":[{"name":"adminlte","slug":"adminlte","permalink":"https://www.esearch.top/tags/adminlte/"}],"categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://www.esearch.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"modal中使用form","date":"2024-04-18T02:14:04.000Z","path":"posts/6646bac6/","text":"html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!-- 更新进展Modal --&gt; &lt;div class=&quot;modal fade&quot; id=&quot;updatemodal&quot; data-backdrop=&quot;static&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;staticBackdropLabel&quot; aria-hidden=&quot;true&quot; name=&quot;updatemodal&quot;&gt; &lt;div class=&quot;modal-dialog modal-xl&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;h5 class=&quot;modal-title&quot; id=&quot;staticBackdropLabel&quot;&gt;更新代办事件&lt;/h5&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;!--编辑框开始--&gt; &lt;div class=&quot;card card-primary&quot;&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;h3 class=&quot;card-title&quot;&gt;更新代办事件&lt;/h3&gt; &lt;/div&gt; &lt;!-- /.card-header --&gt; &lt;!-- form start --&gt; &lt;form id=&quot;updateForm&quot; name=&quot;updateForm&quot; novalidate=&quot;novalidate&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;detail_title&quot;&gt;&lt;a style=&quot;color: red;&quot;&gt;*&lt;/a&gt;进展标题&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;detail_title&quot; class=&quot;form-control&quot; id=&quot;detail_title&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; data-select2-id=&quot;29&quot;&gt; &lt;label&gt;&lt;a style=&quot;color: red;&quot;&gt;*&lt;/a&gt;事件状态&lt;/label&gt; &lt;select class=&quot;form-control select2 select2-danger select2-hidden-accessible&quot; data-dropdown-css-class=&quot;select2-danger&quot; style=&quot;width: 100%;&quot; data-select2-id=&quot;12&quot; tabindex=&quot;-1&quot; aria-hidden=&quot;true&quot; id=&quot;event_status&quot; name=&quot;event_status&quot;&gt; &lt;option selected=&quot;selected&quot; data-select2-id=&quot;14&quot; value=&#x27;0&#x27;&gt;未完成&lt;/option&gt; &lt;option data-select2-id=&quot;35&quot; value=&#x27;1&#x27;&gt;完成&lt;/option&gt; &lt;option data-select2-id=&quot;36&quot; value=&#x27;2&#x27;&gt;终止&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;detail_content&quot;&gt;详细信息(选填)&lt;/label&gt; &lt;textarea id=&quot;detail_content&quot; class=&quot;form-control&quot; name=&quot;detail_content&quot; rows=&quot;4&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- /.card-body --&gt; &lt;/div&gt; &lt;!--编辑框结束--&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-secondary&quot; data-dismiss=&quot;modal&quot;&gt;取消&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;更新&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 更新进展Modal END Modal --&gt; js内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 var updateurl $(&#x27;#updatemodal&#x27;).on(&#x27;show.bs.modal&#x27;, function (event) &#123; var button = $(event.relatedTarget) // Button that triggered the modal //注意这里的whatever对应前面html代码中button标签下data-whatever属性的后半段 updateurl = button.data(&#x27;url&#x27;) // Extract info from data-* attributes // var user = button.data(&#x27;user&#x27;) // If necessary, you could initiate an AJAX request here (and then do the updating in a callback). // Update the modal&#x27;s content. We&#x27;ll use jQuery here, but you could use a data binding library or other methods instead. var modal = $(this) //此处即为修改modal的标题 // modal.find(&#x27;.modal-title&#x27;).text(&#x27;New message to &#x27; + recipient) // modal.find(&#x27;.modal-body input&#x27;).val(recipient) //modal.find(&#x27;.card-primary form&#x27;).attr(&quot;action&quot;,url) &#125;) $(&quot;.modal-footer button[type=&#x27;submit&#x27;]&quot;).click(function(e)&#123; e.preventDefault(); // 阻止表单的默认提交行为 if (!$(&quot;#updateForm&quot;).valid()) &#123; // 如果验证失败，返回false，不提交数据 return false; &#125;; var formData = $(&quot;#updateForm&quot;).serialize(); console.log(&#x27;updateurl&#x27;+updateurl) $.ajax(&#123; url: updateurl, // 你的请求地址 type: &quot;POST&quot;, // 请求类型，必须是POST data: formData, // 你的表单数据 dataType: &quot;json&quot;, // 返回的数据类型，必须是json success: function(data)&#123; if (data.result === 0) &#123; // 请求成功，显示消息 $(&quot;#updatemodal&quot;).modal(&#x27;hide&#x27;) toastr.success(&#x27;成功：&#x27;+data.message) setTimeout(function() &#123; $(&#x27;#eventtable&#x27;).DataTable().ajax.reload(); &#125;, 1000) &#125; else if (data.result === 1) &#123; toastr.error(&#x27;失败：&#x27;+data.message) &#125; &#125;, error: function()&#123; // 请求失败的回调函数 console.log(&quot;Error&quot;); &#125; &#125;);&#125;);$(&#x27;#updateForm&#x27;).validate(&#123; rules: &#123; detail_title: &#123; required: true, minlength: 5 &#125;, &#125;, messages: &#123; detail_title: &#123; required: &quot;请输入更新标题&quot;, &#125;, &#125;, errorElement: &#x27;span&#x27;, errorPlacement: function (error, element) &#123; error.addClass(&#x27;invalid-feedback&#x27;); element.closest(&#x27;.form-group&#x27;).append(error); &#125;, highlight: function (element, errorClass, validClass) &#123; $(element).addClass(&#x27;is-invalid&#x27;); &#125;, unhighlight: function (element, errorClass, validClass) &#123; $(element).removeClass(&#x27;is-invalid&#x27;); &#125;&#125;); django内容 12345&lt;a class=&quot;btn btn-primary btn-sm &#123;disabled&#125;&quot; data-url=&quot;&#123;reverse(&#x27;event:eventupdate&#x27;,kwargs=&#123;&#x27;id&#x27;:Event.id&#125;)&#125;&quot; data-toggle=&quot;modal&quot; data-target=&quot;#updatemodal&quot;&gt; &lt;i class=&quot;fas fa-history&quot;&gt;&lt;/i&gt; &lt;/i&gt; 更新进展&lt;/a&gt;","tags":[{"name":"adminlte","slug":"adminlte","permalink":"https://www.esearch.top/tags/adminlte/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://www.esearch.top/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"adminlte中使用时间插件","date":"2024-04-17T09:29:02.000Z","path":"posts/6646bac8/","text":"daterangepicker 引入文件，语言是由moment控制的 123456&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;% static &#x27;adminlte/plugins/daterangepicker/daterangepicker.css&#x27; %&#125;&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;% static &#x27;adminlte/plugins/tempusdominus-bootstrap-4/css/tempusdominus-bootstrap-4.min.css&#x27; %&#125;&quot;&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/moment/moment.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/moment/locale/zh-cn.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/tempusdominus-bootstrap-4/js/tempusdominus-bootstrap-4.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/daterangepicker/daterangepicker.js&#x27; %&#125;&quot;&gt;&lt;/script&gt; html 123456789&lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;&lt;a style=&quot;color: red;&quot;&gt;*&lt;/a&gt;计划完成时间:&lt;/label&gt; &lt;div class=&quot;input-group date&quot; id=&quot;reservationdatetime&quot; data-target-input=&quot;nearest&quot; &gt; &lt;input type=&quot;text&quot; class=&quot;form-control datetimepicker-input&quot; data-target=&quot;#reservationdatetime&quot; name=&quot;event_deadline&quot; id=&quot;event_deadline&quot; value=&quot;&#123;&#123; event_deadline &#125;&#125;&quot;&gt; &lt;div class=&quot;input-group-append&quot; data-target=&quot;#reservationdatetime&quot; data-toggle=&quot;datetimepicker&quot;&gt; &lt;div class=&quot;input-group-text&quot;&gt;&lt;i class=&quot;fa fa-calendar&quot;&gt;&lt;/i&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 验证，选择的时间不能大于当前时间 12345678910111213141516// 比较时间 $.validator.addMethod(&quot;compareDate&quot;, function(value, element) &#123; var event_deadline = $(&quot;#event_deadline&quot;).val(); var date1 = new Date(Date.parse(event_deadline.replace(&quot;-&quot;, &quot;/&quot;))); // 和当前时间比较 var date2 = new Date(); return date1 &gt;= date2; &#125;,&quot;结束时间不能早于当前时间&quot;); // 表单验证 $(&#x27;#editEventForm&#x27;).validate(&#123; rules: &#123; event_deadline: &#123; required: true, compareDate: true, &#125;, &#125;","tags":[{"name":"adminlte","slug":"adminlte","permalink":"https://www.esearch.top/tags/adminlte/"}],"categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://www.esearch.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"django在windows上开机自启动和打开网页","date":"2024-04-17T08:55:08.000Z","path":"posts/6646bac9/","text":"bat文件 12345@echo off# 使用虚拟环境，如果不用虚拟环境，这句去掉call D:\\python\\testing\\.venv\\Scripts\\activate.bat# 执行python d:python\\django-adminlte-template-master\\django-adminlte-template-master\\manage.py runserver 127.0.0.1:18888 进入下面这个目录，新建一个vbs文件 1C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp vbs文件内容，后面的路径是上面bat文件的路径，网址自定义 12CreateObject(&quot;WScript.Shell&quot;).Run&quot;cmd /c D:\\python\\django-adminlte-template-master\\startDjango.bat&quot;,0CreateObject(&quot;WScript.Shell&quot;).Run&quot;http://127.0.0.1:18888&quot;, 3","tags":[{"name":"django","slug":"django","permalink":"https://www.esearch.top/tags/django/"}],"categories":[{"name":"django","slug":"django","permalink":"https://www.esearch.top/categories/django/"}]},{"title":"django将查询结果转换为字典","date":"2024-04-17T07:07:26.000Z","path":"posts/4b442e59/","text":"查询的结果默认是只读的，不能直接修改，如下面这样 12event = event.objects.get(id=1)event[&#x27;name&#x27;] = 123 有时候可能需要把数据获取到，然后添加一个字段传给前端，这时候就可以用以下的办法 123from django.forms.models import model_to_dictevent = model_to_dict(EventDB.objects.get(id=event_id))event[&#x27;name&#x27;] = 123","tags":[{"name":"django","slug":"django","permalink":"https://www.esearch.top/tags/django/"}],"categories":[{"name":"django","slug":"django","permalink":"https://www.esearch.top/categories/django/"}]},{"title":"在adminlte中使用datatable","date":"2024-04-17T06:40:21.000Z","path":"posts/6646bac4/","text":"基本使用 引入文件 1234567&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;% static &#x27;adminlte/plugins/datatables-bs4/css/dataTables.bootstrap4.min.css&#x27; %&#125;&quot;&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/datatables/jquery.dataTables.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/datatables-bs4/js/dataTables.bootstrap4.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/datatables-responsive/js/dataTables.responsive.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/datatables-responsive/js/responsive.bootstrap4.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/datatables-buttons/js/dataTables.buttons.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/datatables-buttons/js/buttons.bootstrap4.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt; 基本js 123456789101112131415161718192021222324252627282930313233343536373839$(&#x27;#usertable&#x27;).DataTable(&#123; &quot;ajax&quot;: &quot;&#123;% url &#x27;manager:userlist&#x27; %&#125;&quot;, &quot;columns&quot;: [ &#123;&quot;data&quot;: &quot;username&quot;&#125;, &#123;&quot;data&quot;: &quot;create_time&quot;&#125;, &#123;&quot;data&quot;: &quot;superuser&quot;&#125;, &#123;&quot;data&quot;: &quot;passwd_expire_time&quot;&#125;, &#123;&quot;data&quot;: &quot;button&quot;&#125;, ], language: &#123;//自定义语言提示 &quot;processing&quot;: &quot;处理中...&quot;, &quot;lengthMenu&quot;: &quot;显示 _MENU_ 条用户数据&quot;, &quot;zeroRecords&quot;: &quot;没有找到相应的结果&quot;, &quot;info&quot;: &quot;第 _START_ 至 _END_ 行，共 _TOTAL_ 行&quot;, &quot;infoEmpty&quot;: &quot;第 0 至 0 项结果，共 0 项&quot;, &quot;infoFiltered&quot;: &quot;(由 _MAX_ 项结果过滤)&quot;, &quot;infoPostFix&quot;: &quot;&quot;, &quot;url&quot;: &quot;&quot;, &quot;thousands&quot;: &quot;&#x27;&quot;, &quot;emptyTable&quot;: &quot;表中数据为空&quot;, &quot;loadingRecords&quot;: &quot;载入中...&quot;, &quot;infoThousands&quot;: &quot;,&quot;, &quot;paginate&quot;: &#123; &quot;first&quot;: &quot;首页&quot;, &quot;previous&quot;: &quot;上页&quot;, &quot;next&quot;: &quot;下页&quot;, &quot;last&quot;: &quot;末页&quot; &#125; &#125;, // &quot;stateSave&quot;: true, // &quot;bAutoWidth&quot;: true, // &quot;scrollX&quot;: &quot;true&quot;, // &quot;scrollY&quot;: &quot;600px&quot;, // &quot;scrollCollapse&quot;: true, &quot;sDom&quot;: &quot;&lt;&#x27;row&#x27;&lt;&#x27;col-md-6&#x27;&lt;&#x27;#toolbar&#x27;&gt;&gt;&lt;&#x27;col-md-6&#x27;f&gt;&gt;&quot; + //设置表格最上面内容，可以在这里添加按钮等其他设置&quot;t&quot; + //设置tables&quot;&lt;&#x27;row&#x27;&lt;&#x27;col-md-5 sm-center&#x27;li&gt;&lt;&#x27;col-md-7 text-right sm-center&#x27;p&gt;&gt;&quot;,//设置表格最下面显示内容 &#125;); $(&quot;#toolbar&quot;).append(&#x27;&lt;a href=&quot;&#123;% url &quot;manager:usercreate&quot; %&#125;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;&lt;i class=&quot;fa fa-plus-square&quot;&gt;&lt;/i&gt;&amp;nbsp&amp;nbsp新建用户&lt;/button&gt;&lt;/a&gt;&#x27;) html 1234567891011121314&lt;table id=&quot;eventtable&quot; class=&quot;table table-bordered table-striped display hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;完成时间&lt;/th&gt; &lt;th&gt;事件等级&lt;/th&gt; &lt;th&gt;工作量&lt;/th&gt; &lt;th&gt;标签&lt;/th&gt; &lt;th&gt;状态&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt;&lt;/table&gt; 后端分页 html不变 js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var table = $(&#x27;#eventtable&#x27;).DataTable(&#123; &quot;processing&quot;:true, &quot;serverSide&quot;:true, // 服务器分页 &quot;stateSave&quot;: true, //状态保持 &quot;ajax&quot;: &quot;&#123;% url &#x27;event:eventlist&#x27; %&#125;&quot;, &quot;autoWidth&quot;:true,////不开启自动宽度，用bootstrap的自适应去调整 &quot;lengthMenu&quot;: [10,50, 100],//表格行数选择框内数目 显示2条,4条,20条,50条 &quot;displayLength&quot;: 10,//默认的显示行数 (也就是每页显示几条数据) &quot;info&quot;:false, &quot;columns&quot;: [ &#123; &quot;class&quot;:&#x27;details-control&#x27;, &quot;orderable&quot;: true, &quot;data&quot;: null, &quot;defaultContent&quot;: &#x27;&#x27;, &#125;, &#123;&quot;data&quot;: &quot;event_title&quot;&#125;, &#123;&quot;data&quot;: &quot;event_deadline&quot;&#125;, &#123;&quot;data&quot;: &quot;event_level&quot;&#125;, &#123;&quot;data&quot;: &quot;event_workload&quot;&#125;, &#123;&quot;data&quot;: &quot;event_label&quot;&#125;, &#123;&quot;data&quot;: &quot;event_status&quot;&#125;, &#123;&quot;data&quot;: &quot;button&quot;&#125;, ], &quot;order&quot;: [[2, &#x27;asc&#x27;]], &quot;language&quot;: &#123;//自定义语言提示 &quot;processing&quot;: &quot;处理中...&quot;, &quot;lengthMenu&quot;: &quot;显示 _MENU_ 项结果&quot;, &quot;zeroRecords&quot;: &quot;没有找到相应的结果&quot;, &quot;info&quot;: &quot;第 _START_ 至 _END_ 行，共 _TOTAL_ 行&quot;, &quot;infoEmpty&quot;: &quot;第 0 至 0 项结果，共 0 项&quot;, &quot;infoFiltered&quot;: &quot;(由 _MAX_ 项结果过滤)&quot;, &quot;infoPostFix&quot;: &quot;&quot;, &quot;url&quot;: &quot;&quot;, &quot;thousands&quot;: &quot;&#x27;&quot;, &quot;emptyTable&quot;: &quot;表中数据为空&quot;, &quot;loadingRecords&quot;: &quot;载入中...&quot;, &quot;infoThousands&quot;: &quot;,&quot;, &quot;paginate&quot;: &#123; &quot;first&quot;: &quot;首页&quot;, &quot;previous&quot;: &quot;上页&quot;, &quot;next&quot;: &quot;下页&quot;, &quot;last&quot;: &quot;末页&quot; &#125; &#125;, &quot;sDom&quot;: &quot;&lt;&#x27;row&#x27;&lt;&#x27;col-md-6&#x27;&lt;&#x27;#toolbar&#x27;&gt;&gt;&lt;&#x27;col-md-6&#x27;f&gt;&gt;&quot; + //设置表格最上面内容，可以在这里添加按钮等其他设置 &quot;t&quot; + //设置tables &quot;&lt;&#x27;row&#x27;&lt;&#x27;col-md-5 sm-center&#x27;li&gt;&lt;&#x27;col-md-7 text-right sm-center&#x27;p&gt;&gt;&quot; &#125; ); $(&quot;#toolbar&quot;).append(&#x27;&lt;a href=&quot;&#123;% url &quot;event:eventedit&quot; %&#125;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;&lt;i class=&quot;fa fa-plus-square&quot;&gt;&lt;/i&gt;&amp;nbsp&amp;nbsp新建代办&lt;/button&gt;&lt;/a&gt;&#x27;) django 12345678910111213141516171819202122232425262728_query_data = request.GET# 获取开始值start_index = int(_query_data.get(&quot;start&quot;,0))# 获取列表长度search_length = int(_query_data.get(&quot;length&quot;,10))# 算出列表区间end_index = start_index + search_length# 搜索，前端点搜索，search[value]有数据，根据这个数据去搜索if _query_data.get(&#x27;search[value]&#x27;): search_str = _query_data.get(&#x27;search[value]&#x27;) # 搜索有意义的段 EventInfo = EventDB.objects.filter(Q(event_title__icontains=search_str) | Q(event_level__icontains=search_str) | Q(event_detail__icontains=search_str) | Q(event_label__icontains=search_str))else: # 没搜索就查全部 EventInfo = EventDB.objects.all()# 获取排序的列，这里循环了10次，可以根据自己的列数进行调整order_args = []for i in range(0,10): order_column=&#x27;order[%d][column]&#x27; % i if _query_data.get(order_column): order_col = _query_data.get(f&quot;columns[&#123;_query_data.get(order_column)&#125;][data]&quot;) order_args.append(order_col) if _query_data.get(&#x27;order[%d][dir]&#x27; % i) == &quot;asc&quot;: order_col = &#x27;-&#x27; + order_col order_args.append(order_col)# order_by可以传入多个值，在不确定要传入多少个值的情况下，可以把值先保存到列表，再通过*args把列表的多个值传入EventInfo = EventInfo.order_by(*order_args)[start_index:end_index] datatable 定时刷新 12345678$(function () &#123; function refresh() &#123; var table = $(&#x27;#eventtable&#x27;).DataTable(); table.ajax.reload(null, false); // 刷新表格数据，分页信息不会重置 &#125; // 每隔5秒刷新一次数据 setInterval(refresh, 5000);&#125;)","tags":[{"name":"adminlte","slug":"adminlte","permalink":"https://www.esearch.top/tags/adminlte/"}],"categories":[{"name":"django","slug":"django","permalink":"https://www.esearch.top/categories/django/"}]},{"title":"在adminlte中使用select2","date":"2024-04-17T06:40:10.000Z","path":"posts/6646bac3/","text":"引入css和js 123&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;% static &#x27;adminlte/plugins/select2/css/select2.min.css&#x27; %&#125;&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;% static &#x27;adminlte/plugins/select2-bootstrap4-theme/select2-bootstrap4.min.css&#x27; %&#125;&quot;&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/select2/js/select2.full.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt; 基本使用 html 复制的时候把span标签的内容去掉 123456789101112&lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;&lt;a style=&quot;color: red;&quot;&gt;*&lt;/a&gt;标签&lt;/label&gt; &lt;div class=&quot;select2-purple&quot;&gt; &lt;select class=&quot;select2bs4 select2-hidden-accessible&quot; multiple=&quot;&quot; data-dropdown-css-class=&quot;select2-purple&quot; data-placeholder=&quot;Select a State&quot; style=&quot;width: 100%;&quot; data-select2-id=&quot;23&quot; tabindex=&quot;-1&quot; aria-hidden=&quot;true&quot; name=&quot;event_label&quot; id=&quot;event_label&quot;&gt; &lt;option vlaue=&quot;材料&quot;&gt;材料&lt;/option&gt; &lt;option vlaue=&quot;学习&quot;&gt;学习&lt;/option&gt; &lt;option vlaue=&quot;问题处理&quot;&gt;问题处理&lt;/option&gt; &lt;option vlaue=&quot;会议&quot;&gt;会议&lt;/option&gt; &lt;option vlaue=&quot;其它&quot;&gt;其它&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;&lt;/div&gt; js 1$(&quot;#event_label&quot;).select2() 默认值 123456# 默认单选$(&#x27;#event_label&#x27;).val(&quot;Low&quot;)# jquery可以把字符串转换为数组arrValue = &quot;&#123;&#123; event_label &#125;&#125;&quot;.split(&#x27;;&#x27;);# 多选时，传入数组，可以默认选中多个$(&#x27;#event_label&#x27;).val(arrValue).trigger(&#x27;change&#x27;)","tags":[{"name":"adminlte","slug":"adminlte","permalink":"https://www.esearch.top/tags/adminlte/"}],"categories":[{"name":"django","slug":"django","permalink":"https://www.esearch.top/categories/django/"}]},{"title":"Linux创建证书","date":"2024-02-01T01:04:40.000Z","path":"posts/6646b637/","text":"创建证书请求文件CSR和私钥 123456789101112131415161718openssl req -new -nodes -sha256 -newkey rsa:2048 -keyout [$Key_File] -out [$OpenSSL_CSR]说明new：指定生成一个新的 CSR 文件。nodes：指定密钥文件不被加密。sha256：指定摘要算法。newkey rsa:2048：指定密钥类型和长度。[$Key_File]：密钥文件名称。[$OpenSSL_CSR]：加密后文件的存放路径。new：指定生成一个新的 CSR 文件。4. 根据系统返回的提示，输入生成 CSR 文件所需的信息。以下是关于提示的说明：Organization Name：公司名称，可以是中文或英文。Organizational Unit Name：部门名称，可以是中文或英文。Country Code：申请单位所属国家，只能是两个字母的国家码。例如，中国填写为 CN。State or Province Name：州名或省份名称，可以是中文或英文。Locality Name：城市名称，可以是中文或英文。Common Name：申请 SSL 证书的具体网站域名。Email Address：可选择不输入。Challenge Password：可选择不输入。5. 按照命令提示输入相应内容后，即可在当前目录下获取密钥文件和 CSR 文件。 创建证书 1openssl x509 -signkey xxx.key -in xxx.csr -req -days 365 -out xxx.crt 获取证书过期时间 1openssl x509 -in &lt;cert&gt;.pem -noout -enddate","tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://www.esearch.top/tags/Linux%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"}]},{"title":"django和adminlte笔记","date":"2024-01-03T01:26:27.000Z","path":"posts/6646bac2/","text":"django 新增环境 123apt install python3-venvpython3 -m venv django4source django4/bin/active 安装Django 1pip install django -i http://pypi.douban.com/simple/ --trusted-host=pypi.douban.com/simple 创建和初始化项目 创建 1django-admin startproject mysite 修改settings文件 1234567891011121314151617181920212223242526import os # 新增ALLOWED_HOSTS = [&#x27;*&#x27;] #修改# 修改TEMPLATES = [ &#123; &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;, &#x27;DIRS&#x27;: [os.path.join(BASE_DIR,&#x27;templates&#x27;)], #修改 &#x27;APP_DIRS&#x27;: True, &#x27;OPTIONS&#x27;: &#123; &#x27;context_processors&#x27;: [ &#x27;django.template.context_processors.debug&#x27;, &#x27;django.template.context_processors.request&#x27;, &#x27;django.contrib.auth.context_processors.auth&#x27;, &#x27;django.contrib.messages.context_processors.messages&#x27;, ], &#125;, &#125;,]# 以下为修改LANGUAGE_CODE = &#x27;zh-hans&#x27;TIME_ZONE = &#x27;Asia/Shanghai&#x27;USE_TZ = False# 新增staticSTATICFILES_DIRS = [ os.path.join(BASE_DIR, &quot;static&quot;),] 新增文件夹 1mkdir 项目目录/templates 项目目录/static 自定义用户模型 新建一个app 1python manage.py startapp manager 注册到settings.py中 123456789INSTALLED_APPS = [ &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;manager&#x27;, #新增] 修改manager/models.py，根据自己的需要修改 1234567891011121314151617from django.db import modelsfrom django.contrib.auth.models import BaseUserManager,AbstractUserimport uuid# Create your models here.# 自定义user，还需要在setting文件中配置AUTH_USER_MODELSclass UserDB(AbstractUser): uid = models.UUIDField(primary_key=True,default=uuid.uuid4) username = models.CharField(max_length=15,verbose_name=&quot;用户名&quot;, unique=True) phone = models.CharField(max_length=11,verbose_name=&quot;手机号码&quot;, null=True,blank=True) email = models.EmailField(verbose_name=&#x27;邮箱&#x27;, null=True,blank=True) create_time = models.DateTimeField(&#x27;创建时间&#x27;,auto_now_add=True) update_time = models.DateTimeField(&#x27;更新时间&#x27;,auto_now=True) class Meta: verbose_name = &#x27;用户信息&#x27; verbose_name_plural = verbose_name def __str__(self): return self.username 编辑settings.py文件 12# 新增自定义用户模型AUTH_USER_MODEL = &#x27;manager.UserDB&#x27; 数据库迁移 1234#生成迁移文件python manage.py makemigrations#应用迁移文件python manage.py migrate 创建用户 管理员用户 1python manage.py createsuperuser 普通用户进入项目shell 1python manage.py shell 12from django.contrib.auth.models import User(用户数据库，默认为User，如果自定义了这里需要修改)User.objects.create_user(&#x27;username&#x27;, &#x27;email@example.com&#x27;, &#x27;password&#x27;) 站点验证和登录 除了指定界面，用户访问其他界面时，如果没有登录就跳到登录界面，登录完成后跳转到需要访问的界面比如用户访问：https://51yunwei.top/system/ ，会跳转为 https://51yunwei.top/login/?next=/system/，完成登录后，跳转回https://51yunwei.top/system/ 此处代码来自运维咖啡吧，通过中间件的方式进行处理 新建一个目录 1234mkdir system/middleware -pcd system/middlewaretouch __init__.pytouch loginrequired.py 编辑loginrequired.py文件 123456789101112131415from django.shortcuts import redirectfrom django.conf import settingsclass LoginRequiredMiddleware: def __init__(self, get_response): # 启动django的时候会执行init，用get_resonpse来获取下一个中间件或视图函数的响应 self.get_response = get_response self.login_url = settings.LOGIN_URL self.open_urls = [self.login_url] + getattr(settings, &#x27;OPEN_URLS&#x27;, []) # 登录界面和OPEN_URLS里面的路径都是开放的 def __call__(self, request): # 每次有请求到达时，Django都会调用这个方法。 if not request.user.is_authenticated and request.path_info not in self.open_urls: return redirect(self.login_url + &#x27;?next=&#x27; + request.path) return self.get_response(request) # 每个中间件都有一个get_response函数，这个函数会返回下一个中间件或视图函数的响应。 OPEN_URLS：不需要验证就能访问到的界面 LOGIN_URL：需要验证才能访问到的界面通过在settings中配置变量实现 编辑settings文件 123456789101112131415MIDDLEWARE = [ &#x27;django.middleware.security.SecurityMiddleware&#x27;, &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;, &#x27;django.middleware.common.CommonMiddleware&#x27;, # &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;, &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;, &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;, &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;, &#x27;system.middleware.loginrequired.LoginRequiredMiddleware&#x27;, # 新增，根据自己的路径进行修改]&gt; 注意：验证的中间件要放最后面，因为最后一个中间件是第一个执行的。# 新增全局登录地址LOGIN_URL=&#x27;/login/&#x27;OPEN_URLS=[] 在登录的函数中拿到next地址，并返回，如下 1234567891011121314151617181920class LoginView(View): def get(self,request): if request.user.is_authenticated: return render(request,&#x27;base.html&#x27;) return render(request,&#x27;login.html&#x27;) def post(self,request): # 判断用户登录 next_path = request.GET.get(&#x27;next&#x27;,&#x27;/&#x27;) # 虽然是post方法，但还是可以用GET来获取路径的参数，即 ?key=value username = request.POST.get(&#x27;username&#x27;,&#x27;&#x27;) password = request.POST.get(&#x27;password&#x27;,&#x27;&#x27;) # print(&#x27;post next====&#x27;,request.POST.get(&#x27;next&#x27;,&#x27;&#x27;),request.POST) user = authenticate(username=username,password=password) if user: login(request,user) request.session[&quot;username&quot;] = username request.session.set_expiry(0) # 设置session过期时间为一周后 return redirect(next_path) login_error_message = &#x27;用户名或密码错误&#x27; print(&#x27;登录失败&#x27;) return render(request,&#x27;login.html&#x27;,&#123;&#x27;login_error_message&#x27;:login_error_message&#125;) 返回函数 一些常见的视图返回函数的导入方式： HttpResponse：这是一个Django内置的HTTP响应类，可以直接从django.http模块导入。 1from django.http import HttpResponse HttpResponseRedirect：这也是一个Django内置的HTTP响应类，可以直接从django.http模块导入。 1from django.http import HttpResponseRedirect render：这是一个用于渲染模板并返回HTTP响应的函数，可以从django.shortcuts模块导入。 1from django.shortcuts import render redirect：这是一个用于返回重定向视图的函数，也可以从django.shortcuts模块导入。 1from django.shortcuts import redirect JsonResponse：这是一个用于返回JSON格式HTTP响应的函数，可以从django.http模块导入。 1from django.http import JsonResponse Response：这是Django REST Framework中的一个函数，用于返回HTTP响应，需要从rest_framework.response模块导入。 1from rest_framework.response import Response reverse 1from django.urls import reverse 设置url 在项目根urls.py中配置 1234567from django.contrib import adminfrom django.urls import path,include # 新增includeurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;&#x27;, include(&#x27;manager.urls&#x27;)), # 新增，app名称.urls] 在app目录下新建urls.py 123456789from django.urls import pathfrom . import viewsurlpatterns = [ path(&#x27;&#x27;, views.IndexView), path(&#x27;user/&#x27;,views.UserManager.as_view()), path(&#x27;login/&#x27;,views.LoginView.as_view()), path(&#x27;user/&lt;uuid:uid&gt;/&#x27;,views.UserDetail), path(&#x27;logout/&#x27;,views.LogOut),] 使用url模板标签生成路径 在url中配置name 1234567urlpatterns = [ path(&#x27;&#x27;, views.IndexView), path(&#x27;user/&#x27;,views.UserManager.as_view(),name=&#x27;userlist&#x27;), # 配置name path(&#x27;login/&#x27;,views.LoginView.as_view()), path(&#x27;user/&lt;uuid:uid&gt;/&#x27;,views.UserDetail), path(&#x27;logout/&#x27;,views.LogOut),] 在前端文件使用 123&lt;a href=&quot;&#123;% url &#x27;userlist&#x27; %&#125;&quot; class=&quot;nav-link&quot;&gt;&lt;!-- 如果需要用到变量，year为变量 --&gt;&#123;% url &#x27;blog-list&#x27; year %&#125; 如果有多个相同名称的name，可以在urls.py中设置一个app_name来区分 12# manager/urls.pyapp_name=&#x27;manager&#x27; 1&lt;a href=&quot;&#123;% url &#x27;manager:userlist&#x27; %&#125;&quot; class=&quot;nav-link&quot;&gt; 获取post数据 获取post数据 1username = request.POST.get(&#x27;username&#x27;,&#x27;&#x27;) 在post方法中也可以用GET 123def post(self,request): # 判断用户登录 next_path = request.GET.get(&#x27;next&#x27;,&#x27;/&#x27;) # 虽然是post方法，但还是可以用GET来获取路径的参数，即 ?key=value 登录和退出登录和session 登录和session 12345678910from django.contrib.auth import authenticate,login,logoutusername = request.POST.get(&#x27;username&#x27;,&#x27;&#x27;)password = request.POST.get(&#x27;password&#x27;,&#x27;&#x27;)# print(&#x27;post next====&#x27;,request.POST.get(&#x27;next&#x27;,&#x27;&#x27;),request.POST)user = authenticate(username=username,password=password)if user: login(request,user) request.session[&quot;username&quot;] = username # 设置session request.session.set_expiry(0) # 关闭浏览器就过期 return redirect(next_path) 退出登录 12345from django.contrib.auth import authenticate,login,logoutdef LogOut(request): if request.user: logout(request) return redirect(&#x27;/login/&#x27;) 设置密码和检查密码 设置密码使用set_password 1user.set_password(&#x27;xxxx&#x27;) 检查密码是否和输入的一致 12from django.contrib.auth.hashers import check_passwordcheck_password(request.POST.get(&#x27;currpassword&#x27;),user.password) # 输入的密码，数据库中保存的密码 上传到github 1、生成requirements.txt文件 1pip freeze &gt; ./requirements.txt文件 设置全局可使用的变量 在template中，我们可以直接使用request变量，现在我们来设置一下可以直接使用的自定义变量 system/systeminfo.py 1234567891011from manager.models import SystemInfoDBdef SystemInfo(request): system_info = SystemInfoDB.objects.all() if system_info.count(): system_title = system_info.first().system_title if system_info.first().system_title else &#x27;未设置的title&#x27; system_name = system_info.first().system_name if system_info.first().system_name else &#x27;未设置的系统名称&#x27; else: system_title = &#x27;未设置的title&#x27; system_name = &#x27;未设置的系统名称&#x27; return &#123;&#x27;systeminfo&#x27;:&#123;&#x27;system_title&#x27;:system_title,&#x27;system_name&#x27;:system_name&#125;&#125; manager/models.py 12345678class SystemInfoDB(models.Model): system_title = models.CharField(max_length=128,verbose_name=&quot;网页title&quot;) system_name = models.CharField(max_length=128,verbose_name=&quot;站点名称&quot;) class Meta: verbose_name = &#x27;系统信息&#x27; verbose_name_plural = verbose_name def __str__(self): return self.system_name settings.py 12345678910111213141516TEMPLATES = [ &#123; &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;, &#x27;DIRS&#x27;: [os.path.join(BASE_DIR,&#x27;templates&#x27;)], &#x27;APP_DIRS&#x27;: True, &#x27;OPTIONS&#x27;: &#123; &#x27;context_processors&#x27;: [ &#x27;django.template.context_processors.debug&#x27;, &#x27;django.template.context_processors.request&#x27;, &#x27;django.contrib.auth.context_processors.auth&#x27;, &#x27;django.contrib.messages.context_processors.messages&#x27;, &#x27;system.systeminfo.SystemInfo&#x27;, # 新增 ], &#125;, &#125;,] 这样就可以直接在html中使用这个变量了 1&lt;title&gt;&#123;&#123; systeminfo.system_title &#125;&#125;&lt;/title&gt; adminlte 点击菜单加载页面后，菜单没有高亮 在base.html添加以下代码 12345678910&lt;script&gt; // 选择所有class为&#x27;nav-sidebar&#x27;的ul元素下的li元素 $(&#x27;ul.nav-sidebar li&#x27;).each(function(i)&#123; // 检查当前li元素的第一个子元素（即a标签）的href属性值是否为当前路径 if($(this).find(&#x27;a&#x27;).attr(&#x27;href&#x27;)===&#x27;&#123;&#123; request.path &#125;&#125;&#x27;)&#123; // 如果条件满足，则为当前li元素的第一个子元素（即a标签）添加&#x27;active&#x27;类 $(this).find(&#x27;a&#x27;).addClass(&#x27;active&#x27;); &#125; &#125;);&lt;/script&gt; 优化版：比如用户管理一个菜单，里面有编辑用户、查看用户等，url为/user/xxxx/edit/、/user/xxx/detail/，这样的话上面的方法就不管用了，因为菜单是/user/，匹配不到/user/xxx/edit/，所以修改如下： 123456789101112131415161718192021&lt;script&gt; // 选择所有class为&#x27;nav-sidebar&#x27;的ul元素下的li元素 $(&#x27;ul.nav-sidebar li&#x27;).each(function(i)&#123; // 把patharr切割为列表，如[user,xxxx,eidt] var patharr = &#x27;&#123;&#123; request.path &#125;&#125;&#x27;.split(&quot;/&quot;); // 循环列表 for (var i = patharr.length; i &gt; 0; i--) &#123; // 获取列表的值，并转换为字符串 // 比如一开始获取的值为 /user/xxx/edit/,如果没有匹配，下次循环为/user/xxx/，最后为/user/，只要有一个能匹配上，就把菜单高亮 var newpatharr = patharr.slice(0, i); var path = newpatharr.join(&quot;/&quot;)+&#x27;/&#x27;; console.log(path) // 检查当前li元素的第一个子元素（即a标签）的href属性值是否为当前路径 if($(this).find(&#x27;a&#x27;).attr(&#x27;href&#x27;)===path)&#123; // 如果条件满足，则为当前li元素的第一个子元素（即a标签）添加&#x27;active&#x27;类 $(this).find(&#x27;a&#x27;).addClass(&#x27;active&#x27;); break &#125; &#125; &#125;);&lt;/script&gt; data-widget属性 AdminLTE框架中就使用data-widget属性来激活一些插件，如iframe插件、todo list插件等。 以下是一个使用data-widget属性的例子： 1&lt;div class=&quot;col-lg-6&quot; id=&quot;calendar_widget&quot; data-widget=&quot;chat-init&quot;&gt;&lt;/div&gt; 在这个例子中，data-widget=&quot;chat-init&quot;表示激活了一个名为&quot;chat-init&quot;的插件。 需要注意的是，data-widget属性并不是Bootstrap的标准属性，而是一些第三方框架（如AdminLTE）扩展出来的属性。因此，如果你在使用这些框架时遇到data-widget属性，可以参考相应的文档来了解其具体用法。 ajax提交数据 html代码如下 123456789101112131415161718192021&lt;form id=&quot;editUserForm&quot; novalidate=&quot;novalidate&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; id=&quot;username&quot; value=&quot;&#123;&#123; username &#125;&#125;&quot; readonly&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;Email&quot;&gt;邮箱地址&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; class=&quot;form-control&quot; id=&quot;Email&quot; value=&quot;&#123;&#123; email &#125;&#125;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;phone&quot;&gt;手机号码&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; class=&quot;form-control&quot; id=&quot;phone&quot; value=&quot;&#123;&#123; phone &#125;&#125;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /.card-body --&gt; &lt;div class=&quot;card-footer&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;修改&amp;保存&lt;/button&gt; &lt;a href=&quot;&#123;% url &#x27;manager:userlist&#x27; %&#125;&quot; class=&quot;btn btn-success float-right&quot;&gt;&lt;/i&gt; 返回列表&lt;/a&gt; &lt;/div&gt; &lt;/form&gt; ajax代码： 12345678910111213141516171819202122$(&quot;#editUserForm button[type=&#x27;submit&#x27;]&quot;).click(function(e)&#123; e.preventDefault(); // 阻止表单的默认提交行为 var formData = $( &quot;#editUserForm&quot; ).serialize(); $.ajax(&#123; url: &quot;&#123;% url &#x27;manager:useredit&#x27; uid %&#125;&quot;, // 你的请求地址 type: &quot;POST&quot;, // 请求类型，必须是POST data: formData, // 你的表单数据 dataType: &quot;json&quot;, // 返回的数据类型，必须是json success: function(data)&#123; if (data.result === 0) &#123; // 请求成功，显示消息 toastr.success(data.message) &#125; else if (data.result === 1) &#123; toastr.success(data.message) &#125; &#125;, error: function()&#123; // 请求失败的回调函数 console.log(&quot;Error&quot;); &#125; &#125;);&#125;); python代码 1234567891011121314def post(self,request,uid): op_user = request.user if not op_user.is_superuser or op_user.uid != uid: # 如果不是管理员或者修改的不是自己的用户信息 resultdict = &#123;&#x27;result&#x27;:1,&#x27;message&#x27;:&#x27;无权限修改其他用户的信息&#x27;&#125; try: user = UserDB.objects.filter(uid=uid).first() user.email = request.POST.get(&#x27;email&#x27;,&#x27;&#x27;) user.phone = request.POST.get(&#x27;phone&#x27;,&#x27;&#x27;) user.save() resultdict = &#123;&#x27;result&#x27;:0,&#x27;message&#x27;:&#x27;修改成功&#x27;&#125; except Exception as err : resultdict = &#123;&#x27;result&#x27;:1,&#x27;message&#x27;:&#x27;修改用户信息失败%s&#x27; % err&#125; finally: return JsonResponse(resultdict) 吐司 引入文件 123456&lt;!-- toastr需要导入的css文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;% static &#x27;adminlte/plugins/toastr/toastr.min.css&#x27; %&#125;&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;% static &#x27;adminlte/plugins/sweetalert2/sweetalert2.min.css&#x27; %&#125;&quot;&gt;&lt;!-- 吐司需要导入的js --&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/toastr/toastr.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/sweetalert2/sweetalert2.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt; 初始化 123456var Toast = Swal.mixin(&#123; toast: true, position: &#x27;top-end&#x27;, showConfirmButton: false, timer: 3000 # 多少秒后消失 &#125;); 返回上一个url 1&lt;a href=&quot;javascript:history.go(-1);&quot;&gt; 在datatable头添加一个按钮，和search平行 1234567891011&lt;script&gt; $(function () &#123; $(&quot;#usertable&quot;).DataTable(&#123; &quot;responsive&quot;: true, &quot;lengthChange&quot;: false, &quot;autoWidth&quot;: false, &quot;buttons&quot;: [&quot;copy&quot;, &quot;csv&quot;, &quot;excel&quot;, &quot;pdf&quot;, &quot;print&quot;, &quot;colvis&quot;], &quot;sDom&quot;: &quot;&lt;&#x27;row&#x27;&lt;&#x27;col-md-6&#x27;&lt;&#x27;#toolbar&#x27;&gt;&gt;&lt;&#x27;col-md-6&#x27;f&gt;&gt;&quot;,//这里新增 &#125;).buttons().container().appendTo(&#x27;#example1_wrapper .col-md-6:eq(0)&#x27;); $(&quot;#toolbar&quot;).append(&#x27;&lt;a href=&quot;&#123;% url &quot;manager:usercreate&quot; %&#125;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;&lt;i class=&quot;fa fa-plus-square&quot;&gt;&lt;/i&gt;&amp;nbsp&amp;nbsp新建主机&lt;/button&gt;&lt;/a&gt;&#x27;) //这里新增 &#125;); // document.querySelector(&#x27;div.toolbar&#x27;).innerHTML = &#x27;&lt;b&gt;Custom tool bar! Text/images etc.&lt;/b&gt;&#x27;;&lt;/script&gt; post后url显示参数，如何修改？ 123&lt;!-- 在form标签增加以下字段 --&gt;&lt;form onsubmit=&quot;return false&quot; &gt; 提交数据后，通过request.POST获取不到 前端post后，django是通过标签中的name='xxx’获取到数据的，比如，后端通过reqeust.POST.get(‘username’)获取数据所以template一定要设置name属性 自定义模态框的内容 模态框html，id为mymodal 1234567891011121314151617181920212223&lt;!-- 模态框 --&gt;&lt;div class=&quot;modal fade&quot; id=&quot;mymodal&quot; style=&quot;display: none;&quot; aria-hidden=&quot;true&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;mymodaltitle&quot;&gt;&lt;/h4&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;p id=&quot;mymodalcontent&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer justify-content-between&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;取消&lt;/button&gt; &lt;a id=&quot;mymodelhref&quot; style=&quot;color: white;&quot; role=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /.modal-content --&gt; &lt;/div&gt; &lt;!-- /.modal-dialog --&gt;&lt;/div&gt;&lt;!-- 模态框结束 --&gt; js代码 1234567891011121314// 这里用的是模态框的id $(&#x27;#mymodal&#x27;).on(&#x27;show.bs.modal&#x27;, function (event) &#123; var button = $(event.relatedTarget) // Button that triggered the modal //注意这里的whatever对应前面html代码中button标签下data-whatever属性的后半段，这里只要定义了data-xxx，就可以通过js获取 // var recipient = button.data(&#x27;whatever&#x27;) // Extract info from data-* attributes // If necessary, you could initiate an AJAX request here (and then do the updating in a callback). // Update the modal&#x27;s content. We&#x27;ll use jQuery here, but you could use a data binding library or other methods instead. var modal = $(this) //此处即为修改modal的标题，都是通过class获取 modal.find(&#x27;.modal-title&#x27;).text(&#x27;退出登录&#x27;) modal.find(&#x27;.modal-body p&#x27;).text(&quot;是否确认退出登录？&quot;) modal.find(&#x27;.modal-footer a&#x27;).text(&quot;确认退出&quot;) modal.find(&#x27;.modal-footer a&#x27;).attr(&quot;href&quot;,&quot;&#123;% url &#x27;manager:logout&#x27; %&#125;&quot;)&#125;) 按钮的html只要设置了data-toggle=&quot;modal&quot; data-target=&quot;#mymodal&quot;就行，其中data-target是要弹出的模态框 1&lt;a class=&quot;nav-link&quot; href=&quot;/logout/&quot; role=&quot;button&quot; id=&quot;logoutbtn&quot; data-toggle=&quot;modal&quot; data-target=&quot;#mymodal&quot;&gt; jQuery表单校验 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/jquery-validation/jquery.validate.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/jquery-validation/additional-methods.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script&gt;// ajax提交的时候要验证一下$(&quot;#createUserForm button[type=&#x27;submit&#x27;]&quot;).click(function(e)&#123; e.preventDefault(); // 阻止表单的默认提交行为 if (!$(&quot;#createUserForm&quot;).valid()) &#123; // 如果验证失败，返回false，不提交数据 return false; &#125;; var formData = $( &quot;#createUserForm&quot; ).serialize(); $.ajax(&#123; url: &quot;&#123;% url &#x27;manager:usercreate&#x27; %&#125;&quot;, // 你的请求地址 type: &quot;POST&quot;, // 请求类型，必须是POST data: formData, // 你的表单数据 dataType: &quot;json&quot;, // 返回的数据类型，必须是json success: function(data)&#123; if (data.result === 0) &#123; // 请求成功，显示消息 toastr.success(data.message) // window.location.href = &quot;&#123;% url &#x27;manager:userlist&#x27; %&#125;&quot;; setTimeout(function() &#123; window.location.href = &quot;&#123;% url &#x27;manager:userlist&#x27; %&#125;&quot;; &#125;, 1000); &#125; else if (data.result === 1) &#123; toastr.error(data.message) &#125; &#125;, error: function()&#123; // 请求失败的回调函数 console.log(&quot;Error&quot;); &#125; &#125;); &#125;);// 验证规则$.validator.addMethod(&quot;letterswithnumber&quot;, function(value,element) &#123; return this.optional(element) || /^(?=.*[a-z])(?=.*[0-9]).*$/i.test(value); &#125;, &quot;密码中必须包含字母、数字和特殊字符&quot;); $.validator.addMethod(&quot;specialchar&quot;, function(value,element) &#123; return this.optional(element) || /^(?=.*[!@#\\$%\\^&amp;\\*\\(\\)\\-_=+&#123;&#125;:\\,\\&lt;\\&gt;\\?]).*$/i.test(value); &#125;, &quot;密码中必须包含字母、数字和特殊字符&quot;); $(&#x27;#createUserForm&#x27;).validate(&#123; rules: &#123; email: &#123; required: false, email: true, &#125;, password: &#123; required: true, letterswithnumber: true, specialchar: true, minlength: 8 &#125;, confirmpassword: &#123; required: true, equalTo: &quot;#password&quot; &#125;, username: &#123; required: true, pattern: /^[a-zA-Z0-9]+$/, minlength: 5 &#125;, &#125;, messages: &#123; email: &#123; email: &quot;请输入正确的邮箱&quot; &#125;, password: &#123; required: &quot;请提供密码&quot;, etterswithnumber: &quot;密码中必须包含字母和数字&quot;, specialchar: &quot;密码中必须包含特殊字符&quot;, minlength: &quot;密码至少 8 个字符，至少包含三种符号&quot; &#125;, username: &#123; required: &quot;请输入用户名&quot;, minlength: &quot;用户名至少 5 个字符，仅允许字母和数字&quot; &#125;, confirmpassword: &#123; required: &quot;请提供确认密码&quot;, equalTo: &quot;确认密码与密码不一致&quot; &#125;, &#125;, errorElement: &#x27;span&#x27;, errorPlacement: function (error, element) &#123; error.addClass(&#x27;invalid-feedback&#x27;); element.closest(&#x27;.form-group&#x27;).append(error); &#125;, highlight: function (element, errorClass, validClass) &#123; $(element).addClass(&#x27;is-invalid&#x27;); &#125;, unhighlight: function (element, errorClass, validClass) &#123; $(element).removeClass(&#x27;is-invalid&#x27;); &#125; &#125;);&lt;/script&gt; 使用datatable html代码 123456789101112&lt;table id=&quot;usertable&quot; class=&quot;table table-bordered table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;手机号码&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; js代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556$(function () &#123; $(&#x27;#usertable&#x27;).DataTable(&#123; &quot;ajax&quot;: &quot;&#123;% url &#x27;manager:userlist&#x27; %&#125;&quot;, &quot;columns&quot;: [ &#123;&quot;data&quot;: &quot;username&quot;&#125;, &#123;&quot;data&quot;: &quot;create_time&quot;&#125;, &#123;&quot;data&quot;: &quot;email&quot;&#125;, &#123;&quot;data&quot;: &quot;phone&quot;&#125;, &#123;&quot;data&quot;: &quot;button&quot;&#125;, ], language: &#123;//自定义语言提示 &quot;processing&quot;: &quot;处理中...&quot;, &quot;lengthMenu&quot;: &quot;显示 _MENU_ 条用户数据&quot;, &quot;zeroRecords&quot;: &quot;没有找到相应的结果&quot;, &quot;info&quot;: &quot;第 _START_ 至 _END_ 行，共 _TOTAL_ 行&quot;, &quot;infoEmpty&quot;: &quot;第 0 至 0 项结果，共 0 项&quot;, &quot;infoFiltered&quot;: &quot;(由 _MAX_ 项结果过滤)&quot;, &quot;infoPostFix&quot;: &quot;&quot;, &quot;url&quot;: &quot;&quot;, &quot;thousands&quot;: &quot;&#x27;&quot;, &quot;emptyTable&quot;: &quot;表中数据为空&quot;, &quot;loadingRecords&quot;: &quot;载入中...&quot;, &quot;infoThousands&quot;: &quot;,&quot;, &quot;paginate&quot;: &#123; &quot;first&quot;: &quot;首页&quot;, &quot;previous&quot;: &quot;上页&quot;, &quot;next&quot;: &quot;下页&quot;, &quot;last&quot;: &quot;末页&quot; &#125; &#125;, &quot;sDom&quot;: &quot;&lt;&#x27;row&#x27;&lt;&#x27;col-md-6&#x27;&lt;&#x27;#toolbar&#x27;&gt;&gt;&lt;&#x27;col-md-6&#x27;f&gt;&gt;&quot; + //设置表格最上面内容，可以在这里添加按钮等其他设置 &quot;t&quot; + //设置tables &quot;&lt;&#x27;row&#x27;&lt;&#x27;col-md-5 sm-center&#x27;li&gt;&lt;&#x27;col-md-7 text-right sm-center&#x27;p&gt;&gt;&quot;,//设置表格最下面显示内容 buttons: [&#123; text: &#x27;&lt;i class=&quot;fa fa-download&quot; title=&quot;导出execl&quot;&gt;&lt;/i&gt;&#x27;, extend: &#x27;excel&#x27;, // 导出为execl title: &#x27;用户列表&#x27;+Date.now(), // 导出文件的名字 className: &#x27;btn btn-primary&#x27;, // 按钮样式 exportOptions:&#123; columns:[1,2,3,4], // 导出哪些列 // rows:[1,2,3,4] //导出哪些行 modifier: &#123; page: &#x27;all&#x27;, // 导出哪些页的数据，all为所有，current为当前页 &#125;, Headers: true,// 导出表格表头 footer: true,// 导出表格表尾 extension: &quot;.xlsx&quot;, // 导出的文件后缀 &#125; &#125;] &#125;); $(&quot;#toolbar&quot;).append(&#x27;&lt;a href=&quot;&#123;% url &quot;manager:usercreate&quot; %&#125;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;&lt;i class=&quot;fa fa-plus-square&quot;&gt;&lt;/i&gt;&amp;nbsp&amp;nbsp新建用户&lt;/button&gt;&lt;/a&gt;&#x27;) &#125;); 后端代码，返回的格式UserDict[“data”]，data要和js的columns data名称一致 12345678910111213141516171819202122232425262728293031323334353637383940def UserIndex(request): return render(request,&#x27;user/index.html&#x27;)class UserManager(View): def get(self,request): # if not request.META.get(&#x27;HTTP_X_REQUESTED_WITH&#x27;) == &#x27;XMLHttpRequest&#x27;: # return render(request,&#x27;user/index.html&#x27;) # print(&#x27;not ajax request&#x27;) UserInfo = UserDB.objects.all() # print(user) UserList = [] for User in UserInfo: username = User.username create_time =User.create_time email = User.email phone = User.phone button = &quot;&quot;&quot;&lt;div style=&quot;display: block;text-align: center;margin: auto;&quot;&gt; &lt;a class=&quot;btn btn-primary btn-sm&quot; href=&quot;&#123;0&#125;&quot;&gt; &lt;i class=&quot;fas fa-folder&quot;&gt; &lt;/i&gt; 详情 &lt;/a&gt; &lt;a class=&quot;btn btn-info btn-sm&quot; href=&quot;&#123;1&#125;&quot;&gt; &lt;i class=&quot;fas fa-pencil-alt&quot;&gt; &lt;/i&gt; 编辑 &lt;/a&gt; &lt;a class=&quot;btn btn-danger btn-sm&quot; data-url=&quot;&#123;2&#125;&quot; data-user=&#x27;&#123;3&#125;&#x27; data-toggle=&quot;modal&quot; data-target=&quot;#mymodal&quot;&gt; &lt;i class=&quot;fas fa-trash&quot;&gt; &lt;/i&gt; 删除 &lt;/a&gt; &lt;/div&gt; &quot;&quot;&quot;.format(reverse(&#x27;manager:userdetail&#x27;,kwargs=&#123;&#x27;uid&#x27;:User.uid&#125;),reverse(&#x27;manager:useredit&#x27;,kwargs=&#123;&#x27;uid&#x27;:User.uid&#125;),reverse(&#x27;manager:userdel&#x27;,kwargs=&#123;&#x27;uid&#x27;:User.uid&#125;),User.username) UserList.append(&#123;&#x27;username&#x27;: User.username,&#x27;create_time&#x27;:User.create_time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;),&#x27;email&#x27;:User.email,&#x27;phone&#x27;: User.phone,&#x27;uid&#x27;:str(User.uid),&#x27;button&#x27;:button&#125;) print(username) UserDict = &#123;&#125; UserDict[&quot;data&quot;] = UserList return HttpResponse(json.dumps(UserDict)) urls.py 12path(&#x27;user/&#x27;,views.UserIndex,name=&#x27;userindex&#x27;),path(&#x27;user/list/&#x27;,views.UserManager.as_view(),name=&#x27;userlist&#x27;), 刷新datatable的数据 1$(&#x27;#usertable&#x27;).DataTable().ajax.reload(); 截断datatable数据 使用DataTables提供的ellipsis插件，它专门用于文本的截断显示。这个插件可以对过长的文本进行截断，并在结尾添加省略号。使用这个插件非常简单，首先需要在HTML中引入相应的JS文件： 1&lt;script src=&quot;https://cdn.datatables.net/plug-ins/1.11.3/dataRender/ellipsis.js&quot;&gt;&lt;/script&gt; 然后在DataTables的配置中使用render.ellipsis方法： 1234567891011121314$(&#x27;#example&#x27;).DataTable(&#123; // 其他配置 &quot;columnDefs&quot;: [ &#123; &quot;targets&quot;: [ 0 ], &quot;render&quot;: $.fn.dataTable.render.ellipsis( 40 ) // 截断长度为40个字符 &#125; ]&#125;);```js## datatables默认排序```js&quot;order&quot;: [[ 1, &quot;desc&quot; ]] bootstrap-switch监听按钮变化事件 12345$(&quot;#userstat_value&quot;).on(&#x27;switchChange.bootstrapSwitch&#x27;, function (event,state) &#123; var status = this.checked ? &#x27;True&#x27; : &#x27;False&#x27;; console.log(&#x27;userstat&#x27;+status) $(&#x27;input[name=&quot;userstat&quot;]&#x27;).val(status); &#125;); 文件上传 html 123456789&lt;!-- 不在form表单中 --&gt;&lt;div class=&quot;card-body&quot; style=&quot;display: block;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;logoimg&quot;&gt;站点图标(33x33)&lt;/label&gt; &lt;div class=&quot;file-loading&quot;&gt; &lt;input id=&quot;logoimg&quot; name=&quot;logoimg&quot; type=&quot;file&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;script src=&quot;&#123;% static &#x27;adminlte/plugins/bs-custom-file-input/bs-custom-file-input.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;!-- bootstrap 5.x or 4.x is supported. You can also use the bootstrap css 3.3.x versions --&gt;&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt; --&gt;&lt;!-- default icons used in the plugin are from Bootstrap 5.x icon library (which can be enabled by loading CSS below) --&gt;&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.min.css&quot; crossorigin=&quot;anonymous&quot;&gt; --&gt;&lt;!-- alternatively you can use the font awesome icon library if using with `fas` theme (or Bootstrap 4.x) by uncommenting below. --&gt;&lt;!-- link rel=&quot;stylesheet&quot; href=&quot;https://use.fontawesome.com/releases/v5.15.4/css/all.css&quot; crossorigin=&quot;anonymous&quot; --&gt;&lt;!-- the fileinput plugin styling CSS file --&gt;&lt;link href=&quot;https://cdn.jsdelivr.net/gh/kartik-v/bootstrap-fileinput@5.5.2/css/fileinput.min.css&quot; media=&quot;all&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;&lt;!-- if using RTL (Right-To-Left) orientation, load the RTL CSS file after fileinput.css by uncommenting below --&gt;&lt;!-- link href=&quot;https://cdn.jsdelivr.net/gh/kartik-v/bootstrap-fileinput@5.5.2/css/fileinput-rtl.min.css&quot; media=&quot;all&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /--&gt;&lt;!-- the jQuery Library --&gt;&lt;!-- &lt;script src=&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; --&gt;&lt;!-- buffer.min.js and filetype.min.js are necessary in the order listed for advanced mime type parsing and more correct preview. This is a feature available since v5.5.0 and is needed if you want to ensure file mime type is parsed correctly even if the local file&#x27;s extension is named incorrectly. This will ensure more correct preview of the selected file (note: this will involve a small processing overhead in scanning of file contents locally). If you do not load these scripts then the mime type parsing will largely be derived using the extension in the filename and some basic file content parsing signatures. --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/kartik-v/bootstrap-fileinput@5.5.2/js/plugins/buffer.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/kartik-v/bootstrap-fileinput@5.5.2/js/plugins/filetype.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;!-- piexif.min.js is needed for auto orienting image files OR when restoring exif data in resized images and when you wish to resize images before upload. This must be loaded before fileinput.min.js --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/kartik-v/bootstrap-fileinput@5.5.2/js/plugins/piexif.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;!-- sortable.min.js is only needed if you wish to sort / rearrange files in initial preview. This must be loaded before fileinput.min.js --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/kartik-v/bootstrap-fileinput@5.5.2/js/plugins/sortable.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;!-- bootstrap.bundle.min.js below is needed if you wish to zoom and preview file content in a detail modal dialog. bootstrap 5.x or 4.x is supported. You can also use the bootstrap js 3.3.x versions. --&gt;&lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; --&gt;&lt;!-- the main fileinput plugin script JS file --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/kartik-v/bootstrap-fileinput@5.5.2/js/fileinput.min.js&quot;&gt;&lt;/script&gt;&lt;!-- following theme script is needed to use the Font Awesome 5.x theme (`fas`). Uncomment if needed. --&gt;&lt;!-- script src=&quot;https://cdn.jsdelivr.net/gh/kartik-v/bootstrap-fileinput@5.5.2/themes/fas/theme.min.js&quot;&gt;&lt;/script --&gt;&lt;!-- optionally if you need translation for your language then include the locale file as mentioned below (replace LANG.js with your language locale) --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/kartik-v/bootstrap-fileinput@5.5.2/js/locales/LANG.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;#logoimg&quot;).fileinput(&#123; showUpload: true, //显示上传按钮 dropZoneEnabled: false, maxFileCount: 1, //最大选择的文件数 inputGroupClass: &quot;input-group-lg&quot;, allowedFileExtensions: [&quot;png&quot;], // 允许的文件扩展名 language: &#x27;zh&#x27;, uploadUrl: &quot;&#123;% url &#x27;manager:system&#x27; %&#125;&quot;, // 上传的URL &#125;).on(&quot;fileuploaded&quot;, function (e,data,previewId,index) &#123; // 上传成功后触发的事件 toastr.success(&#x27;修改站点图标成功,当前界面可能有缓存,如未更新,请强制刷新一次&#x27;) setTimeout(function() &#123; location.reload(); &#125;, 3000); &#125;); ace编辑器 引入 12&lt;!-- 地址 --&gt;https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.3/ace.min.js 使用 123456789 &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;&lt;a style=&quot;color: red;&quot;&gt;&lt;/a&gt;IP地址（选择黑/白名单时需配置，每行一个IP或网段，如1.1.1.1 或者 1.1.1.0/24）&lt;/label&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;form_content&quot; name=&quot;content&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt; &lt;pre id=&quot;content&quot; style=&quot;height:415px&quot;&gt;&lt;/pre&gt; &lt;/div&gt; &lt;/div&gt;&lt;script src=&quot;&#123;% static &#x27;ace/ace.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt; 12345678910// ACE配置 var editor = ace.edit(&quot;content&quot;); var textarea = $(&#x27;textarea[name=&quot;content&quot;]&#x27;).hide(); editor.getSession().on(&#x27;change&#x27;, function()&#123; textarea.val(editor.getSession().getValue()); &#125;); editor.setShowPrintMargin(false); // 字体大小 editor.setFontSize(18); editor.resize() js换行 12var multiLineString = `这是第一行这是第二行`;","tags":[{"name":"django","slug":"django","permalink":"https://www.esearch.top/tags/django/"},{"name":"adminlte","slug":"adminlte","permalink":"https://www.esearch.top/tags/adminlte/"}],"categories":[{"name":"django","slug":"django","permalink":"https://www.esearch.top/categories/django/"}]},{"title":"测试图片","date":"2023-12-30T04:42:20.000Z","path":"posts/6646bad0/","text":"","tags":[],"categories":[{"name":"博客测试","slug":"博客测试","permalink":"https://www.esearch.top/categories/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/"}]},{"title":"Hello World","date":"2023-12-30T03:31:33.884Z","path":"posts/undefined/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","tags":[],"categories":[{"name":"博客测试","slug":"博客测试","permalink":"https://www.esearch.top/categories/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/"}]},{"title":"Github Page + Hexo 搭建个人博客问题小记","date":"2023-12-28T01:08:08.000Z","path":"posts/6646bac1/","text":"在使用Github Page + Hexo搭建个人博客的时候遇到了一些问题，现记录如下，主题使用的是cactus 问题1 hexo-deployer-git 提示输入用户名/密码 在deploy中配置了token后，使用hexo g -d部署到Github，提示输入用户名密码，但是现在Github已经不支持命令行使用用户名密码登录了，所以需要改为SSH的方式，将deploy的token去掉，repo配置为git@github.com/用户名/仓库名在Github仓库下，选择Settings &gt; Deploy keys &gt;添加一个Deploy key，将系统的~/.ssh/xxxx.pub文件的内容布置上去，然后在GitHub界面勾选Allow write access即可。 问题2 部署hexo后用自定义域名访问显示404，使用用户名.github.io访问正常 方法1 这是因为部署hexo后，原来的CNAME文件被清除了，需要重新设置一下自定义域名。然后在hexo的public文件夹下，新建一个CNAME文件，内容为自定义的域名。如果不写这个文件的话，后面使用hexo g -d，有得重新设置一下自定义域名了。 12cat public/CNAMEwww.51yunwei.top 方法2 一劳永逸的方法，在_config.yml中设置url和插件 12345# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://www.51yunwei.topPlugins:- hexo-generator-cname 安装插件 1npm install hexo-generator-cname 问题3 修改cactus主题样式不生效 按照官方文档修改了_config.yml文件中的colorscheme参数不生效，需要重新执行以下命令，执行完之后自定义域名又不能访问了，按照问题1进行处理。 只要修改了配置文件，都要执行以下命令生成新的新的静态文件 1hexo clean &amp;&amp; hexo deploy 问题4 如何为每篇文章添加文字/图片？ 可以在主题下的layout/post.ejs中添加，把需要添加的内容放在&lt;%- page.content %&gt;后面，如： 12&lt;%- page.content %&gt; &lt;p style=&quot;text-align: center;&quot;&gt; 感谢浏览，如对您有帮助或需联系我，欢迎关注我的微信公众号~&lt;/p&gt;","tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.esearch.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.esearch.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"测试文章","date":"2023-12-27T08:58:43.000Z","path":"posts/6646baca/","text":"Test PageFrom 2023 Test PageForm Gzhou 图片测试 Django学习 https://zhuanlan.zhihu.com/p/113447102 simpleui官网 https://newpanjing.github.io/simpleui_docs/ Test 2024/11/13","tags":[],"categories":[{"name":"博客测试","slug":"博客测试","permalink":"https://www.esearch.top/categories/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/"}]}],"categories":[{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/categories/Prometheus/"},{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/categories/Linux/"},{"name":"工具类","slug":"工具类","permalink":"https://www.esearch.top/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.esearch.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"前端学习","slug":"前端学习","permalink":"https://www.esearch.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"前端","slug":"前端","permalink":"https://www.esearch.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"django","slug":"django","permalink":"https://www.esearch.top/categories/django/"},{"name":"博客测试","slug":"博客测试","permalink":"https://www.esearch.top/categories/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Prometheus","slug":"Prometheus","permalink":"https://www.esearch.top/tags/Prometheus/"},{"name":"Linux","slug":"Linux","permalink":"https://www.esearch.top/tags/Linux/"},{"name":"AlertManager","slug":"AlertManager","permalink":"https://www.esearch.top/tags/AlertManager/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.esearch.top/tags/Nginx/"},{"name":"Shell","slug":"Shell","permalink":"https://www.esearch.top/tags/Shell/"},{"name":"工具","slug":"工具","permalink":"https://www.esearch.top/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Docker","slug":"Docker","permalink":"https://www.esearch.top/tags/Docker/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.esearch.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Database","slug":"Database","permalink":"https://www.esearch.top/tags/Database/"},{"name":"openEuler","slug":"openEuler","permalink":"https://www.esearch.top/tags/openEuler/"},{"name":"kdump","slug":"kdump","permalink":"https://www.esearch.top/tags/kdump/"},{"name":"文件系统","slug":"文件系统","permalink":"https://www.esearch.top/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"Jquery","slug":"Jquery","permalink":"https://www.esearch.top/tags/Jquery/"},{"name":"权限","slug":"权限","permalink":"https://www.esearch.top/tags/%E6%9D%83%E9%99%90/"},{"name":"Linux基础","slug":"Linux基础","permalink":"https://www.esearch.top/tags/Linux%E5%9F%BA%E7%A1%80/"},{"name":"hexo","slug":"hexo","permalink":"https://www.esearch.top/tags/hexo/"},{"name":"adminlte","slug":"adminlte","permalink":"https://www.esearch.top/tags/adminlte/"},{"name":"django","slug":"django","permalink":"https://www.esearch.top/tags/django/"}]}
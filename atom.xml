<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>运维少年</title>
  
  <subtitle>运维少年的博客</subtitle>
  <link href="https://www.esearch.top/atom.xml" rel="self"/>
  
  <link href="https://www.esearch.top/"/>
  <updated>2024-10-08T08:58:43.135Z</updated>
  <id>https://www.esearch.top/</id>
  
  <author>
    <name>运维少年</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Prometheus的rule文件中使用判断语句和变量</title>
    <link href="https://www.esearch.top/posts/25711707/"/>
    <id>https://www.esearch.top/posts/25711707/</id>
    <published>2024-10-08T08:55:26.000Z</published>
    <updated>2024-10-08T08:58:43.135Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>话不多说，直接给出示例，相信一眼就能看到怎么用了</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hostStatsAlert300s</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">5m</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">磁盘使用率超过阈值告警</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">((node_filesystem_size_bytes</span> <span class="bullet">-</span> <span class="string">node_filesystem_avail_bytes)</span> <span class="string">/</span> <span class="string">node_filesystem_size_bytes)</span> <span class="string">*</span> <span class="string">on(instance)</span> <span class="string">group_left(nodename)</span> <span class="string">(node_uname_info)</span> <span class="string">&gt;</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">labels:</span> </span><br><span class="line">      <span class="attr">severity:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; if gt $value 0.9 &#125;&#125;</span> 紧急告警 <span class="template-variable">&#123;&#123; else if gt $value 0.8 &#125;&#125;</span> 重要告警 <span class="template-variable">&#123;&#123; else if gt $value 0.7 &#125;&#125;</span> 次要告警 <span class="template-variable">&#123;&#123; end &#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">&quot;主机 <span class="template-variable">&#123;&#123; $labels.nodename &#125;&#125;</span>  目录 <span class="template-variable">&#123;&#123; $labels.mountpoint &#125;&#125;</span> 磁盘使用率过高&quot;</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">&quot;主机<span class="template-variable">&#123;&#123; $labels.nodename &#125;&#125;</span> 磁盘使用率过高，告警阈值：<span class="template-variable">&#123;&#123; if gt $value 0.9 &#125;&#125;</span>90<span class="template-variable">%&#123;&#123; else if gt $value 0.8 &#125;</span>&#125;80<span class="template-variable">%&#123;&#123; else if gt $value 0.7 &#125;</span>&#125;70<span class="template-variable">%&#123;&#123; end &#125;</span>&#125;，当前使用率：<span class="template-variable">&#123;&#123; $value | humanizePercentage &#125;&#125;</span>，目录：<span class="template-variable">&#123;&#123; $labels.mountpoint &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>$labels</code>：在web界面查询出来的所有标签值都能用</p></li><li class="lvl-2"><p><code>$value</code>：警报触发时的表达式计算结果</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;话不多说，直接给出示例，相信一眼就能看到怎么用了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="Prometheus" scheme="https://www.esearch.top/categories/Prometheus/"/>
    
    
    <category term="Prometheus" scheme="https://www.esearch.top/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus告警中如何携带主机名</title>
    <link href="https://www.esearch.top/posts/cbb5ee1c/"/>
    <id>https://www.esearch.top/posts/cbb5ee1c/</id>
    <published>2024-10-08T08:48:43.000Z</published>
    <updated>2024-10-08T08:54:30.394Z</updated>
    
    <content type="html"><![CDATA[<p>主机名<code>（nodename）</code>在指标<code>node_uname_info</code>中，且<code>node_uname_info</code>的值恰巧为1，所以我们可以在<code>PromQL</code>中通过<code>node_uname_info</code>提取，只需要在原有<code>PromQL</code>后添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* on(instance) group_left(nodename) (node_uname_info)</span><br></pre></td></tr></table></figure><p>这样，在prometheus告警的labels中，就可以通过nodename获取主机名了</p><p>比如原先的expr为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">node_filesystem_size_bytes</span> <span class="bullet">-</span> <span class="string">node_filesystem_avail_bytes)</span> <span class="string">/</span> <span class="string">node_filesystem_size_bytes</span> <span class="string">&gt;</span> <span class="number">0.7</span></span><br></pre></td></tr></table></figure><p>修改为以下的expr就行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">((node_filesystem_size_bytes</span> <span class="bullet">-</span> <span class="string">node_filesystem_avail_bytes)</span> <span class="string">/</span> <span class="string">node_filesystem_size_bytes)</span> <span class="string">*</span> <span class="string">on</span> <span class="string">(instance)</span> <span class="string">group_left</span> <span class="string">(nodename)</span> <span class="string">(node_uname_info)</span> <span class="string">&gt;</span> <span class="number">0.7</span></span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><blockquote><ul class="lvl-1"><li class="lvl-2"><p><a href="https://www.cnblogs.com/heian99/p/15257897.html#:~:text=%E4%B8%BB%E6%9C%BA%E5%90%8D%EF%BC%88nodena">Prometheus监控，生产可用告警规则（可获取主机名）</a></p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主机名&lt;code&gt;（nodename）&lt;/code&gt;在指标&lt;code&gt;node_uname_info&lt;/code&gt;中，且&lt;code&gt;node_uname_info&lt;/code&gt;的值恰巧为1，所以我们可以在&lt;code&gt;PromQL&lt;/code&gt;中通过&lt;code&gt;node_un</summary>
      
    
    
    
    <category term="Prometheus" scheme="https://www.esearch.top/categories/Prometheus/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
    <category term="Prometheus" scheme="https://www.esearch.top/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>热重载Prometheus和AlertManager配置文件</title>
    <link href="https://www.esearch.top/posts/ed0140b7/"/>
    <id>https://www.esearch.top/posts/ed0140b7/</id>
    <published>2024-10-08T08:05:40.000Z</published>
    <updated>2024-10-08T08:13:43.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果每次修改配置文件都需要重启服务，那就太操蛋了。</p></blockquote><h1>Prometheus配置文件重载</h1><p><strong>必要条件</strong>：Prometheus在2.0版本后<code>hot reload</code> 功能是默认关闭的，如需开启，需要在启动<code>Prometheus</code>的时候，添加<code> --web.enable-lifecycle</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Docker 运行示例</span></span><br><span class="line">docker run -d  --name prom-server prometheus --web.enable-lifecycle --config.file=/etc/prometheus/prometheus.yml</span><br></pre></td></tr></table></figure><p><strong>重载文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">curl -X POST http://WEBURL/-/reload</span><br></pre></td></tr></table></figure><p>接下来就可以看文件有没有<code>reload</code>日志打印了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ts=2024-10-08T07:38:57.506Z <span class="built_in">caller</span>=main.go:1367 level=info msg=<span class="string">&quot;Loading configuration file&quot;</span> filename=/etc/prometheus/prometheus.yml</span><br><span class="line">ts=2024-10-08T07:38:57.508Z <span class="built_in">caller</span>=main.go:1415 level=info msg=<span class="string">&quot;Completed loading of configuration file&quot;</span> filename=/etc/prometheus/prometheus.yml totalDuration=1.791304ms db_storage=1.533µs remote_storage=1.493µs web_handler=471ns query_engine=1.122µs scrape=74.5µs scrape_sd=39.955µs notify=17.532µs notify_sd=11.622µs rules=1.293589ms tracing=2.935µs</span><br><span class="line">ts=2024-10-08T07:39:24.210Z <span class="built_in">caller</span>=main.go:1367 level=info msg=<span class="string">&quot;Loading configuration file&quot;</span> filename=/etc/prometheus/prometheus.yml</span><br><span class="line">ts=2024-10-08T07:39:24.212Z <span class="built_in">caller</span>=main.go:1415 level=info msg=<span class="string">&quot;Completed loading of configuration file&quot;</span> filename=/etc/prometheus/prometheus.yml totalDuration=1.753011ms db_storage=1.512µs remote_storage=1.503µs web_handler=541ns query_engine=1.182µs scrape=84.148µs scrape_sd=37.81µs notify=15.93µs notify_sd=9.338µs rules=1.194914ms tracing=3.727µs</span><br><span class="line">ts=2024-10-08T08:02:58.620Z <span class="built_in">caller</span>=main.go:1367 level=info msg=<span class="string">&quot;Loading configuration file&quot;</span> filename=/etc/prometheus/prometheus.yml</span><br><span class="line">ts=2024-10-08T08:02:58.622Z <span class="built_in">caller</span>=main.go:1415 level=info msg=<span class="string">&quot;Completed loading of configuration file&quot;</span> filename=/etc/prometheus/prometheus.yml totalDuration=1.705142ms db_storage=1.603µs remote_storage=1.803µs web_handler=501ns query_engine=1.062µs scrape=81.222µs scrape_sd=34.655µs notify=15.208µs notify_sd=10.019µs rules=1.183322ms tracing=3.437µs</span><br></pre></td></tr></table></figure><h1>AlertManager文件重载</h1><p><code>AlertManager</code>默认支持热重载文件，通过以下命令进行重载操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://WEBURL/-/reload</span><br></pre></td></tr></table></figure><p>查看日志是否有<code>reload</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ts=2024-10-08T08:13:15.421Z <span class="built_in">caller</span>=coordinator.go:113 level=info component=configuration msg=<span class="string">&quot;Loading configuration file&quot;</span> file=/etc/alertmanager/alertmanager.yml</span><br><span class="line">ts=2024-10-08T08:13:15.422Z <span class="built_in">caller</span>=coordinator.go:126 level=info component=configuration msg=<span class="string">&quot;Completed loading of configuration file&quot;</span> file=/etc/alertmanager/alertmanager.yml</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果每次修改配置文件都需要重启服务，那就太操蛋了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Prometheus配置文件重载&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;必要条件&lt;/strong&gt;：Prometheus在2.0版本后&lt;code&gt;hot re</summary>
      
    
    
    
    <category term="Prometheus" scheme="https://www.esearch.top/categories/Prometheus/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
    <category term="Prometheus" scheme="https://www.esearch.top/tags/Prometheus/"/>
    
    <category term="AlertManager" scheme="https://www.esearch.top/tags/AlertManager/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus-AlertManager设置邮件发送告警信息</title>
    <link href="https://www.esearch.top/posts/6bafdf3f/"/>
    <id>https://www.esearch.top/posts/6bafdf3f/</id>
    <published>2024-10-05T09:36:08.000Z</published>
    <updated>2024-10-05T09:42:59.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以网易163邮箱为例</p></blockquote><p>修改<code>alertmanager.yml</code>文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">resolve_timeout:</span> <span class="string">5m</span> <span class="comment"># 当警报恢复后，等待这个时长才认为警报真正解决</span></span><br><span class="line">  <span class="attr">smtp_from:</span> <span class="string">&#x27;xxxx@163.com&#x27;</span> <span class="comment"># 发送警报邮件的发件人邮箱地址</span></span><br><span class="line">  <span class="attr">smtp_smarthost:</span> <span class="string">&#x27;smtp.163.com:465&#x27;</span> <span class="comment"># 邮件发送使用的SMTP服务器地址和端口</span></span><br><span class="line">  <span class="attr">smtp_auth_username:</span> <span class="string">&#x27;xxx@163.com&#x27;</span> <span class="comment"># 用于SMTP认证的用户名，通常是发件人的邮箱地址</span></span><br><span class="line">  <span class="attr">smtp_auth_password:</span> <span class="string">&#x27;xxxxxxx&#x27;</span> <span class="comment"># 用于SMTP认证的密码，这里应该是邮箱的授权码（token），而非登录密码</span></span><br><span class="line">  <span class="attr">smtp_require_tls:</span> <span class="literal">false</span> <span class="comment"># 是否要求使用TLS加密邮件传输，这里设置为false表示不强制要求</span></span><br><span class="line">  <span class="attr">smtp_hello:</span> <span class="string">&#x27;163.com&#x27;</span> <span class="comment"># SMTP连接时的HELO/EHLO标识，通常使用邮件服务商的域名</span></span><br><span class="line"></span><br><span class="line"><span class="attr">route:</span></span><br><span class="line">  <span class="attr">group_by:</span> [<span class="string">&#x27;alertname&#x27;</span>] <span class="comment"># 按照警报名称对警报进行分组</span></span><br><span class="line">  <span class="attr">group_wait:</span> <span class="string">30s</span> <span class="comment"># 在将警报发送给接收者之前等待的时间，以便收集更多相关警报</span></span><br><span class="line">  <span class="attr">group_interval:</span> <span class="string">5m</span> <span class="comment"># 分组后，每隔这个时长检查一次是否有新警报加入同一分组</span></span><br><span class="line">  <span class="attr">repeat_interval:</span> <span class="string">1h</span> <span class="comment"># 对于同一个分组的警报，每隔这个时长重复发送一次通知</span></span><br><span class="line">  <span class="attr">receiver:</span> <span class="string">&#x27;163email&#x27;</span> <span class="comment"># 默认的警报通知接收者，这里引用了下面定义的receivers中的一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># receivers中定义了警报通知的接收者，包括他们的联系方式</span></span><br><span class="line"><span class="attr">receivers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;163email&#x27;</span> <span class="comment"># 接收者的名称，用于在route中引用</span></span><br><span class="line">    <span class="attr">email_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">&#x27;xxx@yeah.net&#x27;</span> <span class="comment"># 接收警报邮件的邮箱地址</span></span><br><span class="line">        <span class="attr">send_resolved:</span> <span class="literal">true</span> <span class="comment"># 当警报恢复时，是否发送恢复通知邮件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;以网易163邮箱为例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改&lt;code&gt;alertmanager.yml&lt;/code&gt;文件&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    <category term="Prometheus" scheme="https://www.esearch.top/categories/Prometheus/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
    <category term="Prometheus" scheme="https://www.esearch.top/tags/Prometheus/"/>
    
    <category term="AlertManager" scheme="https://www.esearch.top/tags/AlertManager/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus基于文件的自动发现</title>
    <link href="https://www.esearch.top/posts/13b4287e/"/>
    <id>https://www.esearch.top/posts/13b4287e/</id>
    <published>2024-10-05T09:05:05.000Z</published>
    <updated>2024-10-08T08:05:09.474Z</updated>
    
    <content type="html"><![CDATA[<h1>一、自动发现服务</h1><p>每次修改<code>Prometheus</code>配置文件都需要重载服务，未免有些麻烦，而自动发现服务就是为了解决这种麻烦事儿的，自动发现服务又分为好几种，其中基于文件的服务发现是最通用的方式。这种方式不需要依赖于任何的平台或者第三方服务。<code>Prometheus</code>会定时从文件中读取最新的<code>Target</code>信息，因此，我们可以通过任意的方式将监控<code>Target</code>的信息写入即可。</p><h1>二、配置</h1><h2 id="步骤1-修改prometheus-yml文件">步骤1 修改<code>prometheus.yml</code>文件</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;file_sd_default&#x27;</span></span><br><span class="line">  <span class="attr">file_sd_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">files:</span> [<span class="string">&#x27;/etc/prometheus/config/sd_config/*.yml&#x27;</span>]</span><br><span class="line">    <span class="attr">refresh_interval:</span> <span class="string">5s</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>file_sd_configs</code>：说明配置为基于文件的自动发现服务</p></li><li class="lvl-2"><p><code>files</code>：文件存放位置</p></li><li class="lvl-2"><p><code>refresh_interval</code>: 读取的周期</p></li></ul><h2 id="步骤2-创建targets文件">步骤2 创建targets文件</h2><ul class="lvl-0"><li class="lvl-2"><p>创建文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /etc/prometheus/config/sd_config/xxx.yml</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>写入targets</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;localhost:9090&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>如果需要添加验证，则需要在jobs添加</strong></p><ul class="lvl-0"><li class="lvl-2"><p>修改<code>prometheus.yml</code>文件</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;file_sd_node&#x27;</span></span><br><span class="line">    <span class="attr">file_sd_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">files:</span> [<span class="string">&#x27;/etc/prometheus/config/sd_config/node/node.yml&#x27;</span>]</span><br><span class="line">      <span class="attr">refresh_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">basic_auth:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">用户名</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">密码</span></span><br></pre></td></tr></table></figure><p>通过这种方式，Prometheus会自动的周期性读取文件中的内容。当文件中定义的内容发生变化时，不需要对Prometheus进行任何的重启操作。</p><p><code>Targets</code>可以通过<code>Promethtus</code>的<code>web</code>界面，<code>Status &gt; Targets</code>查看</p><h1>三、Rule的自动加载</h1><p>Rule无法使用Targets的方式，推荐办法是在修改完Rule之后，使用以下命令进行配置的重新加载（不是重启）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">kill</span> -HUP $(pgrep prometheus)</span><br><span class="line"><span class="comment"># 或者使用curl方式</span></span><br><span class="line">curl -X POST http://WEBIP/-/reload</span><br></pre></td></tr></table></figure><p><strong><code>HUP</code>信号</strong></p><ul class="lvl-0"><li class="lvl-2"><p>全称：<code>Hang Up signal</code>。</p></li><li class="lvl-2"><p>用途：当进程接收到<code>HUP</code>信号时，它通常会执行挂起操作，这通常意味着进程会关闭打开的文件描述符并重新读取其配置文件。对于许多守护进程<code>（daemon）</code>来说，<code>HUP</code>信号是一个请求进程重新加载配置文件的常用方式。</p></li><li class="lvl-2"><p>常见使用场景：<code>HUP</code>信号常用于服务的平滑重启，特别是对于那些需要持续运行且不能轻易停止的服务。通过发送HUP信号，可以让服务在不中断的情况下重新加载配置。因此，当你执行<code>sudo kill -HUP pgrep prometheus</code>命令时，你实际上是在告诉系统向所有名为<code>prometheus</code>的进程发送一个<code>HUP</code>信号，请求它们重新加载配置文件。这对于<code>Prometheus</code>这样的监控服务非常有用，因为它允许管理员在不中断监控服务的情况下更新配置。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、自动发现服务&lt;/h1&gt;
&lt;p&gt;每次修改&lt;code&gt;Prometheus&lt;/code&gt;配置文件都需要重载服务，未免有些麻烦，而自动发现服务就是为了解决这种麻烦事儿的，自动发现服务又分为好几种，其中基于文件的服务发现是最通用的方式。这种方式不需要依赖于任何的平台或者第三方</summary>
      
    
    
    
    <category term="Prometheus" scheme="https://www.esearch.top/categories/Prometheus/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
    <category term="Prometheus" scheme="https://www.esearch.top/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>阿里云-使用Prometheus配置报警规则的最佳实践</title>
    <link href="https://www.esearch.top/posts/68a5e006/"/>
    <id>https://www.esearch.top/posts/68a5e006/</id>
    <published>2024-10-04T06:55:12.000Z</published>
    <updated>2024-10-05T09:42:42.016Z</updated>
    
    <content type="html"><![CDATA[<h1>使用Prometheus配置报警规则的最佳实践 - 阿里云</h1><p><code>ACK</code>从集群稳定性、集群节点异常、集群节点水位、应用容器副本异常、工作负载异常、存储异常、网络异常等多个方面，通过集群、应用的运维经验沉淀，总结梳理出以下<code>Prometheus</code>重要报警规则配置。</p><p>报警规则包含容器副本异常、工作负载异常等内容，分为以下级别。</p><ul class="lvl-0"><li class="lvl-2"><p><code>Critical</code>：造成集群、应用、甚至业务影响，需要立即处理。</p></li><li class="lvl-2"><p><code>Warning</code>：造成集群、应用、甚至业务影响，需要尽快排查。</p></li><li class="lvl-2"><p><code>Normal</code>：涉及重要功能变更。</p></li></ul><h1>报警规则说明</h1><p>ACK从集群稳定性、集群节点异常、集群节点水位、应用容器副本异常、工作负载异常、存储异常、网络异常等多个方面，通过集群、应用的运维经验沉淀，总结梳理出以下Prometheus重要报警规则配置。</p><h2 id="容器副本异常">容器副本异常</h2><table><thead><tr><th>详细描述</th><th>重要级别</th><th>PromQL配置</th><th>规则说明</th><th>常见处理SOP流程</th></tr></thead><tbody><tr><td>Pod状态异常</td><td>Critical</td><td><code>min_over_time(sum by (namespace, pod, phase) (kube_pod_status_phase&#123;phase=~&quot;Pending|Unknown|Failed&quot;&#125;)[5m:1m]) &gt; 0</code></td><td>最近5分钟内，Pod的状态有异常时，触发报警。</td><td>关于Pod状态异常的处理方法，请参见<a href="#">Pod异常问题排查</a>。</td></tr><tr><td>Pod启动失败</td><td>Critical</td><td><code>sum_over_time(increase(kube_pod_container_status_restarts_total&#123;&#125;)[5m:1m]) &gt; 3</code></td><td>最近5分钟内，Pod启动异常累计3次以上时，触发报警。</td><td>关于Pod启动失败的处理方法，请参见<a href="#">Pod异常问题排查</a>。</td></tr><tr><td>超1000个Pod调度失败异常</td><td>Critical</td><td><code>sum(sum(max_over_time(kube_pod_status_phase&#123; phase=~&quot;Pending&quot;&#125;[5m])) by (pod)) &gt; 1000</code></td><td>最近5分钟内，累计有1000个Pod处于调度失败Pending状态时，触发报警。</td><td>可能是大规模集群调度场景下任务压力过大引起的。推荐使用ACK集群Pro版。</td></tr><tr><td>容器CPU限流频繁</td><td>Warning</td><td><code>rate(container_cpu_cfs_throttled_seconds_total[3m]) * 100 &gt; 25</code></td><td>容器CPU被频繁限流。最近3分钟内，被限流的CPU时间片大于25%时，触发报警。</td><td>针对这种情况，请评估Pod的CPU资源Limit是否配置过小。推荐使用CPU Burst性能优化策略。</td></tr><tr><td>容器副本Pod的CPU资源水位高于85%</td><td>Warning</td><td><code>sum(irate(container_cpu_usage_seconds_total&#123;pod=~&quot;&#123;&#123;PodName&#125;&#125;.*&quot;,namespace=~&quot;&#123;&#123;Namespace&#125;&#125;.*&quot;,container!=&quot;&quot;,container!=&quot;POD&quot;&#125;[1m])) by (namespace,pod) / sum(container_spec_cpu_quota&#123;pod=~&quot;&#123;&#123;PodName&#125;&#125;.*&quot;,namespace=~&quot;&#123;&#123;Namespace&#125;&#125;.*&quot;,container!=&quot;&quot;,container!=&quot;POD&quot;&#125;/100000) by (namespace,pod) * 100 &lt;= 100 or on() vector(0) &gt;= 85</code></td><td>在指定命名空间或Pod下，容器副本Pod的CPU资源水位超过Pod Limit的85%时，会触发报警。</td><td>当Pod的CPU资源水位较高时，会造成CPU资源限流，导致CPU时间片分配不足，最终影响Pod中进程的执行。</td></tr><tr><td>容器副本Pod的内存资源水位高于85%</td><td>Warning</td><td><code>(sum(container_memory_working_set_bytes&#123;pod=~&quot;&#123;&#123;PodName&#125;&#125;.*&quot;,namespace=~&quot;&#123;&#123;Namespace&#125;&#125;.*&quot;,container !=&quot;&quot;,container!=&quot;POD&quot;&#125;) by (pod,namespace)/ sum(container_spec_memory_limit_bytes&#123;pod=~&quot;&#123;&#123;PodName&#125;&#125;.*&quot;,namespace=~&quot;&#123;&#123;Namespace&#125;&#125;.*&quot;,container !=&quot;&quot;,container!=&quot;POD&quot;&#125;) by (pod, namespace) * 100) &lt;= 100 or on() vector(0) &gt;= 85</code></td><td>容器副本Pod的内存资源水位高于Pod Limit的85%时，触发报警。</td><td>当Pod的内存资源水位较高时，会造成Pod被OOMKilled，继而导致Pod重启。</td></tr></tbody></table><h2 id="工作负载异常">工作负载异常</h2><table><thead><tr><th>详细描述</th><th>重要级别</th><th>PromQL配置</th><th>规则说明</th><th>常见处理SOP流程</th></tr></thead><tbody><tr><td>Deployment可用副本状态异常</td><td>Critical</td><td><code>kube_deployment_spec_replicas&#123;&#125; != kube_deployment_status_replicas_available&#123;&#125;</code></td><td>Deployment可用副本数未达到预期时，触发报警。</td><td>确定是否有Deployment的Pod启动失败。</td></tr><tr><td>DaemonSet副本状态异常</td><td>Critical</td><td><code>((100 - kube_daemonset_status_number_ready&#123;&#125; / kube_daemonset_status_desired_number_scheduled&#123;&#125; * 100) or (kube_daemonset_status_desired_number_scheduled&#123;&#125; - kube_daemonset_status_current_number_scheduled&#123;&#125;)) &gt; 0</code></td><td>DaemonSet的可用副本数未达到预期时，触发报警。</td><td>确定是否有Deployment的Pod启动失败。</td></tr><tr><td>DaemonSet副本调度异常</td><td>Critical</td><td><code>kube_daemonset_status_number_misscheduled&#123;job&#125; &gt; 0</code></td><td>DaemonSet的副本调度异常时，触发报警。</td><td>确定是否有Deployment的Pod启动失败。</td></tr><tr><td>Job运行失败</td><td>Critical</td><td><code>kube_job_status_failed&#123;&#125; &gt; 0</code></td><td>Job执行失败时，触发报警。</td><td>在对应Job下的Pod的日志中查看详细失败信息。</td></tr></tbody></table><h2 id="存储异常">存储异常</h2><table><thead><tr><th>详细描述</th><th>重要级别</th><th>PromQL配置</th><th>规则说明</th><th>常见处理SOP流程</th></tr></thead><tbody><tr><td>PersistentVolume状态异常</td><td>Critical</td><td><code>kube_persistentvolume_status_phase&#123;phase=~&quot;Failed|Pending&quot;&#125; &gt; 0</code></td><td>存储卷PV状态异常时，触发报警。</td><td>关于PersistentVolume状态异常的处理方法，请参见<a href="#">云盘存储卷FAQ</a>的云盘挂载内容。</td></tr><tr><td>节点磁盘空间不足10%</td><td>Critical</td><td><code>((node_filesystem_avail_bytes * 100) / node_filesystem_size_bytes) &lt; 10</code></td><td>节点某磁盘块设备可用空间不足10%时，触发报警。</td><td>建议扩容节点和节点磁盘。</td></tr></tbody></table><h2 id="节点状态异常">节点状态异常</h2><table><thead><tr><th>详细描述</th><th>重要级别</th><th>PromQL配置</th><th>规则说明</th><th>常见处理SOP流程</th></tr></thead><tbody><tr><td>节点NotReady状态持续3分钟</td><td>Critical</td><td><code>(sum(max_over_time(kube_node_status_condition&#123;condition=&quot;Ready&quot;,status=&quot;true&quot;&#125;[3m]) &lt;= 0) by (node)) or (absent(kube_node_status_condition&#123;condition=&quot;Ready&quot;,status=&quot;true&quot;&#125;)) &gt; 0</code></td><td>集群节点NotReady状态持续3分钟时，触发报警。</td><td>确定节点NotReady状态是否符合预期。</td></tr></tbody></table><h2 id="宿主机水位异常">宿主机水位异常</h2><table><thead><tr><th>详细描述</th><th>重要级别</th><th>PromQL配置</th><th>规则说明</th><th>常见处理SOP流程</th></tr></thead><tbody><tr><td>宿主机内存水位高于85%</td><td>Warning</td><td><code>(100 - node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes * 100) &gt;= 85</code></td><td>该集群的宿主机内存水位高于85%时，触发报警。</td><td>释放资源。推荐使用成本洞察功能检查是否有Pod占用了可调度资源。</td></tr><tr><td>宿主机内存水位高于90%</td><td>Critical</td><td><code>(100 - node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes * 100) &gt;= 90</code></td><td>该集群的宿主机内存水位高于90%。</td><td>释放资源。推荐使用成本洞察功能检查是否有Pod占用了可调度资源。</td></tr><tr><td>宿主机CPU水位高于85%</td><td>Warning</td><td><code>100 - (avg by(instance) (rate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[2m])) * 100) &gt;= 85</code></td><td>该集群的宿主机CPU水位高于85%时，触发报警。</td><td>释放资源。推荐使用成本洞察功能检查是否有Pod占用了可调度资源。</td></tr><tr><td>宿主机CPU水位高于90%</td><td>Critical</td><td><code>100 - (avg by(instance) (rate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[2m])) * 100) &gt;= 90</code></td><td>该集群的宿主机CPU水位高于90%时，触发报警。</td><td>释放资源。推荐使用成本洞察功能检查是否有Pod占用了可调度资源。</td></tr></tbody></table><h2 id="节点资源异常">节点资源异常</h2><table><thead><tr><th>详细描述</th><th>重要级别</th><th>PromQL配置</th><th>规则说明</th><th>常见处理SOP流程</th></tr></thead><tbody><tr><td>节点CPU资源分配率高于85%</td><td>Normal</td><td><code>(sum(sum(kube_pod_container_resource_requests&#123;resource=&quot;cpu&quot;&#125;) by (pod, node) * on (pod) group_left max(kube_pod_status_ready) by (pod, node)) by (node)) / sum(kube_node_status_allocatable&#123;resource=&quot;cpu&quot;&#125;) by (node) * 100 &gt;= 85</code></td><td>该集群节点的CPU已分配水位高于85%时，触发报警。</td><td>该节点可再被调度的资源不足，超过可分配规格的Pod需要被调度到其他节点。</td></tr><tr><td>节点CPU超卖率高于300%</td><td>Warning</td><td><code>(sum(sum(kube_pod_container_resource_limits&#123;resource=&quot;cpu&quot;&#125;) by (pod, node) * on (pod) group_left max(kube_pod_status_ready) by (pod, node)) by (node)) / sum(kube_node_status_allocatable&#123;resource=&quot;cpu&quot;&#125;) by (node) * 100 &gt;= 300</code></td><td>该集群节点的CPU超卖水位高于300%时，触发报警。</td><td>节点上已调度的Pod的资源Limit的总和远大于节点总可分配资源。</td></tr><tr><td>节点内存使用水位高于85%</td><td>Warning</td><td><code>sum(container_memory_working_set_bytes&#123;pod!=&quot;&quot;&#125;) by (node) / sum(kube_node_status_allocatable&#123;resource=&quot;memory&quot;&#125;) by (node) * 100 &gt;= 85</code></td><td>该集群节点的内存水位高于85%时，触发报警。</td><td>释放资源。推荐使用成本洞察功能检查是否有Pod占用了可调度资源。</td></tr><tr><td>节点内存资源分配率高于85%</td><td>Normal</td><td><code>(sum(sum(kube_pod_container_resource_requests&#123;resource=&quot;memory&quot;&#125;) by (pod, node) * on (pod) group_left max(kube_pod_status_ready) by (pod, node)) by (node)) / sum(kube_node_status_allocatable&#123;resource=&quot;memory&quot;&#125;) by (node) * 100 &gt;= 85</code></td><td>该集群节点的内存已分配水位高于85%时，触发报警。</td><td>该节点可再被调度的资源不足，超过可分配规格的Pod需要被调度到其他节点。</td></tr><tr><td>节点内存超卖率高于300%</td><td>Warning</td><td><code>(sum(sum(kube_pod_container_resource_limits&#123;resource=&quot;memory&quot;&#125;) by (pod, node) * on (pod) group_left max(kube_pod_status_ready) by (pod, node)) by (node)) / sum(kube_node_status_allocatable&#123;resource=&quot;memory&quot;&#125;) by (node) * 100 &gt;= 300</code></td><td>该集群节点的内存超卖水位高于300%时，触发报警。</td><td>节点上已调度的Pod的资源限制Limit的总和远大于节点总可分配资源。</td></tr></tbody></table><h2 id="网络异常">网络异常</h2><table><thead><tr><th>详细描述</th><th>重要级别</th><th>PromQL配置</th><th>规则说明</th><th>常见处理SOP流程</th></tr></thead><tbody><tr><td>集群CoreDNS可用性异常-请求跌零</td><td>Critical</td><td><code>(sum(rate(coredns_dns_request_count_total&#123;&#125;[1m]))by(server,zone)&lt;=0) or (sum(rate(coredns_dns_requests_total&#123;&#125;[1m]))by(server,zone)&lt;=0)</code></td><td>仅ACK托管集群（Pro版、基础版）支持检测该异常。</td><td>检查集群中CoreDNS Pod是否正常。</td></tr><tr><td>集群CoreDNS可用性异常-panic异常</td><td>Critical</td><td><code>sum(rate(coredns_panic_count_total&#123;&#125;[3m])) &gt; 0</code></td><td>仅ACK托管集群（Pro版、基础版）支持检测该异常。</td><td>检查集群中CoreDNS Pod是否正常。若CoreDNS行为不符合预期，请提交工单咨询。</td></tr><tr><td>集群IngressController证书即将过期</td><td>Warning</td><td><code>((nginx_ingress_controller_ssl_expire_time_seconds - time()) / 24 / 3600) &lt; 14</code></td><td>您需要安装部署ACK Ingress Controller组件，并开启Ingress功能。</td><td>重新签发Ingress Controller证书。</td></tr></tbody></table><h2 id="弹性伸缩异常">弹性伸缩异常</h2><table><thead><tr><th>详细描述</th><th>重要级别</th><th>PromQL配置</th><th>规则说明</th><th>常见处理SOP流程</th></tr></thead><tbody><tr><td>HPA当前副本数已达最大副本设置数</td><td>Warning</td><td><code>max(kube_horizontalpodautoscaler_spec_max_replicas) by (namespace, horizontalpodautoscaler) - max(kube_horizontalpodautoscaler_status_current_replicas) by (namespace, horizontalpodautoscaler) &lt;= 0</code></td><td>您需要在阿里云Prometheus启用<code>horizontalpodautoscaler</code>相关指标（默认关闭）。此指标为免费指标。</td><td>请检查HPA策略是否符合预期。</td></tr></tbody></table><hr><p><strong>说明</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>规则说明中的操作入口指报警配置页面的报警规则管理页签。您可以登录容器服务管理控制台，在集群列表页面，单击目标集群名称，然后在左侧导航栏，选择报警配置。在报警配置页面，单击报警规则管理页签，进行对应报警规则的更新。</p></li><li class="lvl-2"><p>85%的默认阈值为推荐的参考值，实际取值可以以您的业务情况为准。</p></li><li class="lvl-2"><p>针对某些报警规则，可能需要根据实际情况调整PromQL配置中的参数，以适应不同的监控需求。</p></li></ul><h2 id="参考资料">参考资料</h2><blockquote><ul class="lvl-1"><li class="lvl-2"><p><a href="https://help.aliyun.com/zh/ack/ack-managed-and-ack-dedicated/user-guide/best-practices-for-configuring-alert-rules-in-prometheus#p-zyd-s4g-kem">使用Prometheus配置报警规则的最佳实践</a></p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;使用Prometheus配置报警规则的最佳实践 - 阿里云&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ACK&lt;/code&gt;从集群稳定性、集群节点异常、集群节点水位、应用容器副本异常、工作负载异常、存储异常、网络异常等多个方面，通过集群、应用的运维经验沉淀，总结梳理出以下&lt;code&gt;Pr</summary>
      
    
    
    
    <category term="Prometheus" scheme="https://www.esearch.top/categories/Prometheus/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
    <category term="Prometheus" scheme="https://www.esearch.top/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>node_exporter添加访问验证</title>
    <link href="https://www.esearch.top/posts/3b0a5d69/"/>
    <id>https://www.esearch.top/posts/3b0a5d69/</id>
    <published>2024-10-03T07:46:13.000Z</published>
    <updated>2024-10-05T09:42:56.665Z</updated>
    
    <content type="html"><![CDATA[<p>假设你想要求所有访问<code>Prometheus</code>实例的用户提供用户名和密码。为了这个例子，使用<code>admin</code>作为用户名，并选择任何你喜欢的密码。</p><h1>步骤1：密码哈希</h1><p>首先，生成密码的<code>bcrypt</code>哈希值。为了生成哈希密码，我们将使用python3-bcrypt。让我们通过运行apt install python3-bcrypt来安装它，假设你正在运行类似<code>debian</code>的发行版。其他替代方案也存在来生成哈希密码；为了测试，你也可以使用网上的bcrypt生成器。</p><p>这里是一个使用<code>python3-bcrypt</code>的<code>python</code>脚本，它会提示你输入密码并对其进行哈希处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"><span class="keyword">import</span> bcrypt</span><br><span class="line"><span class="comment"># 提示输入密码</span></span><br><span class="line">password = getpass.getpass(<span class="string">&quot;password: &quot;</span>)</span><br><span class="line">hashed_password = bcrypt.hashpw(password.encode(<span class="string">&quot;utf-8&quot;</span>), bcrypt.gensalt())</span><br><span class="line"><span class="comment"># 获取密码的哈希值</span></span><br><span class="line"><span class="built_in">print</span>(hashed_password.decode())</span><br></pre></td></tr></table></figure><h1>步骤2：创建web.yml</h1><p>让我们创建一个<code>web.yml</code>文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">basic_auth_users:</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="string">$2b$12$hNf2lSsxfm0.i4a.1kVpSOVyBCfIB51VRjgBUyv6kdnyTlgWj81Ay</span></span><br></pre></td></tr></table></figure><blockquote><p>注意用户名:【空格】密码</p></blockquote><p>你可以使用<code>promtool check web-config web.yml</code>来验证该文件</p><h1>步骤3：启动Prometheus</h1><p>你可以使用<code>web</code>配置文件来启动<code>prometheus</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ prometheus --web.config.file=web.yml</span><br></pre></td></tr></table></figure><h1>步骤4：测试</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">curl -u admin http://localhost:9090/metrics</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>（可选）步骤5：node_exporter以docker的方式运行</h1><p>在原有运行容器的命令中加上<code>--web.config.file=/xxx/xxx/web.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原有命令</span></span><br><span class="line">docker run -d   --net=<span class="string">&quot;host&quot;</span>   --pid=<span class="string">&quot;host&quot;</span>   -v <span class="string">&quot;/:/host:ro,rslave&quot;</span> --name prom-node  quay.io/prometheus/node-exporter:latest   --path.rootfs=/host</span><br><span class="line"><span class="comment"># 启用验证命令</span></span><br><span class="line">docker run -d   --net=<span class="string">&quot;host&quot;</span>   --pid=<span class="string">&quot;host&quot;</span>   -v <span class="string">&quot;/:/host:ro,rslave&quot;</span> --name prom-node  quay.io/prometheus/node-exporter:latest   --path.rootfs=/host --web.config.file=/host/data/prometheus/config.yml</span><br></pre></td></tr></table></figure><h1>步骤6：在server端的<code>prometheus.yml</code>添加验证信息</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;node&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;xxx.xxx.xxx.xxx:9100&#x27;</span>]</span><br><span class="line">    <span class="attr">basic_auth:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">admin</span> <span class="comment"># 用户名</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">xxxx</span> <span class="comment"># 明文密码</span></span><br></pre></td></tr></table></figure><h1>步骤7：测试验证</h1><p>登录到<code>server</code>前台，验证是否能够获取<code>node</code>数据</p><h2 id="参考资料">参考资料</h2><blockquote><ul class="lvl-1"><li class="lvl-2"><p><a href="https://prometheus.io/docs/guides/basic-auth/">Securing Prometheus API and UI endpoints using basic auth</a></p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假设你想要求所有访问&lt;code&gt;Prometheus&lt;/code&gt;实例的用户提供用户名和密码。为了这个例子，使用&lt;code&gt;admin&lt;/code&gt;作为用户名，并选择任何你喜欢的密码。&lt;/p&gt;
&lt;h1&gt;步骤1：密码哈希&lt;/h1&gt;
&lt;p&gt;首先，生成密码的&lt;code&gt;bcryp</summary>
      
    
    
    
    <category term="Prometheus" scheme="https://www.esearch.top/categories/Prometheus/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
    <category term="Prometheus" scheme="https://www.esearch.top/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>nginx 代理设置访问密码（不依赖htpasswd工具）</title>
    <link href="https://www.esearch.top/posts/f2baa4c/"/>
    <id>https://www.esearch.top/posts/f2baa4c/</id>
    <published>2024-10-03T03:12:29.000Z</published>
    <updated>2024-10-03T03:18:05.242Z</updated>
    
    <content type="html"><![CDATA[<h1>Nginx访问密码配置（无需htpasswd）</h1><p>要在Nginx中配置访问密码而不依赖于<code>htpasswd</code>等第三方工具，可以按照以下步骤手动创建密码文件并在Nginx配置中引用它。</p><h2 id="步骤1：创建密码文件">步骤1：创建密码文件</h2><ol><li class="lvl-3"><p><strong>生成加密密码</strong>：使用编程语言或在线工具生成加密密码。例如，使用Python的<code>crypt</code>模块：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypt</span><br><span class="line"><span class="built_in">print</span>(crypt.crypt(<span class="string">&quot;your_password&quot;</span>, <span class="string">&quot;salt&quot;</span>))</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p><strong>保存密码文件</strong>：创建一个文本文件（如<code>passwords</code>），并将加密后的密码保存在其中，格式为：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username:$apr1$...$...</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p><strong>存放密码文件</strong>：将<code>passwords</code>文件放置在安全的位置，如<code>/etc/nginx/</code>目录下。</p></li></ol><h2 id="步骤2：编辑Nginx配置文件">步骤2：编辑Nginx配置文件</h2><ol><li class="lvl-3"><p><strong>打开配置文件</strong>：编辑<code>Nginx</code>主配置文件<code>/etc/nginx/nginx.conf</code>或相关虚拟主机配置文件。</p></li><li class="lvl-3"><p><strong>添加认证指令</strong>：在相应的<code>server</code>块或<code>location</code>块中添加以下指令以启用基本认证：</p></li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">auth_basic</span> <span class="string">&quot;Restricted&quot;</span>;</span><br><span class="line">    <span class="attribute">auth_basic_user_file</span> /etc/nginx/passwords;</span><br><span class="line">    <span class="comment"># 其他配置...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>auth_basic &quot;Restricted&quot;</code>;定义了认证提示信息。</p></li><li class="lvl-2"><p><code>auth_basic_user_file</code>指定之前创建的密码文件路径。</p></li></ul><h2 id="步骤3：重新加载">步骤3：重新加载</h2><p>保存配置文件更改后，重启Nginx服务以应用新设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="步骤4：测试访问">步骤4：测试访问</h2><p>尝试访问网站，系统应提示输入用户名和密码。使用在<code>passwords</code>文件中定义的凭据登录，若正确，可正常访问网站。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Nginx访问密码配置（无需htpasswd）&lt;/h1&gt;
&lt;p&gt;要在Nginx中配置访问密码而不依赖于&lt;code&gt;htpasswd&lt;/code&gt;等第三方工具，可以按照以下步骤手动创建密码文件并在Nginx配置中引用它。&lt;/p&gt;
&lt;h2 id=&quot;步骤1：创建密码文件&quot;&gt;步骤</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.esearch.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
    <category term="Nginx" scheme="https://www.esearch.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Debian脚本中使用了&amp;&gt;/dev/null，$?总是返回0</title>
    <link href="https://www.esearch.top/posts/78eb14d2/"/>
    <id>https://www.esearch.top/posts/78eb14d2/</id>
    <published>2024-09-30T09:33:10.000Z</published>
    <updated>2024-09-30T09:52:48.976Z</updated>
    
    <content type="html"><![CDATA[<h1>一、问题现象</h1><p>在<code>CentOS</code>中编写了一段<code>Shell</code>脚本，作用很简单，就是监控nginx的配置文件是否发生了变化，如果发生了变化就自动<code>reload</code>一次，脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  md5=`<span class="built_in">md5sum</span> /etc/nginx/conf.d/port-to-domain.conf | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line">  grep <span class="variable">$&#123;md5&#125;</span> /tmp/md5result &amp;&gt;/dev/null</span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> `<span class="built_in">date</span>` <span class="string">&#x27;Config File Change&#x27;</span></span><br><span class="line">    <span class="built_in">echo</span> `<span class="built_in">date</span>` <span class="string">&#x27;Command nginx -t exec&#x27;</span></span><br><span class="line">    nginx -t</span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> `<span class="built_in">date</span>` <span class="string">&#x27;Command nginx -t exec success&#x27;</span></span><br><span class="line">      nginx -s reload</span><br><span class="line">      <span class="built_in">echo</span> `<span class="built_in">date</span>` <span class="string">&#x27;Command nginx -s reload exec&#x27;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> `<span class="built_in">date</span>` <span class="string">&#x27;Command nginx -t exec failed&#x27;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;md5&#125;</span> &gt; /tmp/md5result</span><br><span class="line">    <span class="built_in">echo</span> `<span class="built_in">date</span>` <span class="string">&#x27;Change md5result&#x27;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> `<span class="built_in">date</span>` <span class="string">&#x27;Config File NoChange&#x27;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">sleep</span> 5</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>在<code>CentOS</code>中运行一切正常，但是在Debian中运行异常，具体是<code>grep $&#123;md5&#125; /tmp/md5result &amp;&gt;/dev/null</code>的返回值总是0</p><ul class="lvl-0"><li class="lvl-2"><p>Centos执行过程</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 ~]<span class="comment"># sh -x monitor.sh </span></span><br><span class="line">+ <span class="literal">true</span></span><br><span class="line">++ <span class="built_in">md5sum</span> /etc/nginx/conf.d/port-to-domain.conf</span><br><span class="line">++ awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">+ md5=37e9863c68386613dd0ee4b3a5183380</span><br><span class="line">+ grep 37e9863c68386613dd0ee4b3a5183380 /tmp/md5result</span><br><span class="line">+ <span class="string">&#x27;[&#x27;</span> 1 -ne 0 <span class="string">&#x27;]&#x27;</span> <span class="comment"># 正常返回非0值</span></span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">&#x27;Config File Change&#x27;</span></span><br><span class="line">Config File Change</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Debian系统执行过程</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@cd3b9bf29db3:/<span class="comment"># sh -x monitor.sh </span></span><br><span class="line">+ <span class="literal">true</span></span><br><span class="line">+ <span class="built_in">md5sum</span> /etc/nginx/conf.d/port-to-domain.conf</span><br><span class="line">+ awk &#123;<span class="built_in">print</span> <span class="variable">$1</span>&#125;</span><br><span class="line">+ md5=bca7fa98ab245fa12a4a70a9b15e8b9a</span><br><span class="line">+ </span><br><span class="line">+ [ 0 -ne 0 ]  <span class="comment"># 结果返回0，即使/tmp/md5result不存在也返回0</span></span><br><span class="line">+ grep bca7fa98ab245fa12a4a70a9b15e8b9a /tmp/md5result</span><br><span class="line">+ <span class="built_in">date</span></span><br><span class="line">+ <span class="built_in">echo</span> Mon Sep 30 09:21:43 UTC 2024 Config File NoChange</span><br></pre></td></tr></table></figure><h1>二、问题排查</h1><ul class="lvl-0"><li class="lvl-2"><p>我在Debian的命令行手动执行以上命令，均无问题。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@cd3b9bf29db3:/<span class="comment"># md5=`md5sum /etc/nginx/conf.d/port-to-domain.conf | awk &#x27;&#123;print $1&#125;&#x27;`</span></span><br><span class="line">root@cd3b9bf29db3:/<span class="comment"># grep $&#123;md5&#125; /tmp/md5result &amp;&gt;/dev/null</span></span><br><span class="line">root@cd3b9bf29db3:/<span class="comment"># echo $?</span></span><br><span class="line">2 <span class="comment"># 返回正常</span></span><br><span class="line">root@cd3b9bf29db3:/<span class="comment">#  </span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>尝试将<code>&amp;&gt;/dev/null</code>删除掉，再测试，发现正常了，不知道是啥原因导致的异常。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@cd3b9bf29db3:/<span class="comment"># sh -x monitor.sh </span></span><br><span class="line">+ <span class="literal">true</span></span><br><span class="line">+ <span class="built_in">md5sum</span> /etc/nginx/conf.d/port-to-domain.conf</span><br><span class="line">+ awk &#123;<span class="built_in">print</span> <span class="variable">$1</span>&#125;</span><br><span class="line">+ md5=bca7fa98ab245fa12a4a70a9b15e8b9a</span><br><span class="line">+ grep bca7fa98ab245fa12a4a70a9b15e8b9a /tmp/md5result</span><br><span class="line">grep: /tmp/md5result: No such file or directory</span><br><span class="line">+ [ 2 -ne 0 ] <span class="comment"># 返回值正常了</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>我尝试修改了运行脚本的方式，从<code>sh scritp.sh</code> 修改为<code>bash script.sh</code>，结果成功了</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@cd3b9bf29db3:/<span class="comment"># echo &gt; /tmp/md5result </span></span><br><span class="line"><span class="comment"># bash 与预期相符</span></span><br><span class="line">root@cd3b9bf29db3:/<span class="comment"># bash monitor.sh </span></span><br><span class="line">Mon Sep 30 09:48:11 UTC 2024 Config File Change</span><br><span class="line">Mon Sep 30 09:48:11 UTC 2024 Command nginx -t <span class="built_in">exec</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">Mon Sep 30 09:48:11 UTC 2024 Command nginx -t <span class="built_in">exec</span> success</span><br><span class="line">2024/09/30 09:48:11 [notice] 592<span class="comment">#592: signal process started</span></span><br><span class="line">Mon Sep 30 09:48:11 UTC 2024 Command nginx -s reload <span class="built_in">exec</span></span><br><span class="line">Mon Sep 30 09:48:11 UTC 2024 Change md5result</span><br><span class="line">Mon Sep 30 09:48:16 UTC 2024 Config File NoChange</span><br><span class="line">^C</span><br><span class="line">root@cd3b9bf29db3:/<span class="comment"># echo 1 &gt; /tmp/md5result </span></span><br><span class="line"><span class="comment"># sh 与预期不相符</span></span><br><span class="line">root@cd3b9bf29db3:/<span class="comment"># sh monitor.sh </span></span><br><span class="line">Mon Sep 30 09:48:38 UTC 2024 Config File NoChange</span><br><span class="line">Mon Sep 30 09:48:43 UTC 2024 Config File NoChange</span><br></pre></td></tr></table></figure><h1>三、结论</h1><blockquote><p>这个结论是问AI的您遇到的问题很可能是由于sh和bash在处理某些命令或脚本构造时的行为差异所致。在Linux系统中，sh通常指的是POSIX shell，而bash是Bourne Again SHell的简称，它是GNU项目的一个兼容sh的shell程序，提供了许多sh没有的特性和改进。</p></blockquote><p><strong>为啥CentOS可以，Debian不行?</strong><br>应该是sh的版本等不同造成的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、问题现象&lt;/h1&gt;
&lt;p&gt;在&lt;code&gt;CentOS&lt;/code&gt;中编写了一段&lt;code&gt;Shell&lt;/code&gt;脚本，作用很简单，就是监控nginx的配置文件是否发生了变化，如果发生了变化就自动&lt;code&gt;reload&lt;/code&gt;一次，脚本如下：&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.esearch.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
    <category term="Shell" scheme="https://www.esearch.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>使用docker安装webssh</title>
    <link href="https://www.esearch.top/posts/e0c5f301/"/>
    <id>https://www.esearch.top/posts/e0c5f301/</id>
    <published>2024-09-24T09:31:30.000Z</published>
    <updated>2024-09-24T15:19:14.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>部署webssh，可以实现使用浏览器ssh登录，摆脱工具的限制</p></blockquote><h1>部署</h1><ul class="lvl-0"><li class="lvl-2"><p>docker运行</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --log-driver json-file --log-opt max-file=1 --log-opt max-size=100m -p 8032:5032 --restart always --name webssh -e TZ=Asia/Shanghai -e authInfo=用户名:密码 -e savePass=<span class="literal">false</span> jrohy/webssh</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>支持添加的环境变量：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">port: web使用端口, 默认5032</span><br><span class="line">savePass: 是否保存密码, 默认true</span><br><span class="line">authInfo: 开启账号密码登录验证, &#x27;user:pass&#x27;的格式设置</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>打开网页<br><img src="/img/webssh2.png" alt="webssh"></p></li></ul><h1>nginx反向代理(可选)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">map <span class="variable">$http_upgrade</span> <span class="variable">$connection_upgrade</span> &#123;</span><br><span class="line">    default keep-alive;</span><br><span class="line">    <span class="string">&#x27;websocket&#x27;</span> upgrade;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    client_max_body_size 1024m;</span><br><span class="line">    server_name     webssh.域名.top;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header        Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_pass      http://0.0.0.0:8032; <span class="comment"># 转发</span></span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;  <span class="comment">#获取客户端真实IP</span></span><br><span class="line">        proxy_set_header REMOTE-HOST <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        proxy_set_header Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        add_header Access-Control-Allow-Origin *;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;部署webssh，可以实现使用浏览器ssh登录，摆脱工具的限制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;部署&lt;/h1&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;docker运行&lt;/p&gt;
&lt;/li&gt;
&lt;/</summary>
      
    
    
    
    <category term="工具类" scheme="https://www.esearch.top/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
    <category term="工具" scheme="https://www.esearch.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Docker" scheme="https://www.esearch.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>gitpage 套上 cloudflare后显示过多重定向问题解决</title>
    <link href="https://www.esearch.top/posts/6c7d376/"/>
    <id>https://www.esearch.top/posts/6c7d376/</id>
    <published>2024-09-17T08:07:35.000Z</published>
    <updated>2024-09-17T08:12:04.818Z</updated>
    
    <content type="html"><![CDATA[<h1>一、现象</h1><p>在<code>cloudflare</code>设置好dns之后，gitpage页面无法打开，显示<strong>将您重定向的次数过多</strong></p><h1>二、解决办法</h1><p>在<code>cloudflare</code>的<code>SSL/TLS</code> &gt; <code>概述</code>中，将<code>SSL/TLS加密</code>修改为灵活即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、现象&lt;/h1&gt;
&lt;p&gt;在&lt;code&gt;cloudflare&lt;/code&gt;设置好dns之后，gitpage页面无法打开，显示&lt;strong&gt;将您重定向的次数过多&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;二、解决办法&lt;/h1&gt;
&lt;p&gt;在&lt;code&gt;cloudflare&lt;/code</summary>
      
    
    
    
    <category term="博客搭建" scheme="https://www.esearch.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="博客搭建" scheme="https://www.esearch.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>OpenEuler 安装MySql</title>
    <link href="https://www.esearch.top/posts/b5a91e2c/"/>
    <id>https://www.esearch.top/posts/b5a91e2c/</id>
    <published>2024-09-10T01:22:10.000Z</published>
    <updated>2024-09-10T01:29:18.330Z</updated>
    
    <content type="html"><![CDATA[<p><strong>安装mysql</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-server -y</span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure><p><strong>目录授权</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R mysql:mysql /var/lib/mysql/</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果在/etc/my.cnf.d/my.cnf中修改了目录路径，需要对相关路径进行权限修改。</p></blockquote><p><strong>设置登录密码</strong></p><ul class="lvl-0"><li class="lvl-2"><p>修改配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="comment">#在mysqld模块下添加</span></span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>重启服务</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>进入数据库</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment"># 在提示密码时直接按回车</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在数据库中刷新权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>修改密码</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;newpassword&#x27;</span>;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="comment">#在mysqld模块下删除</span></span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>重启服务就可以使用密码登录了</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;安装mysql&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.esearch.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
    <category term="Database" scheme="https://www.esearch.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>openEuler开启kdump失败</title>
    <link href="https://www.esearch.top/posts/1c033694/"/>
    <id>https://www.esearch.top/posts/1c033694/</id>
    <published>2024-06-24T07:23:00.000Z</published>
    <updated>2024-06-26T03:17:26.486Z</updated>
    
    <content type="html"><![CDATA[<h1>一、现象</h1><p>openEuler启动kdump失败，显示<code>No memory reserved for crash kernel</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># systemctl status kdump</span></span><br><span class="line"> kdump.service - Crash recovery kernel arming</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/system/kdump.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: failed (Result: exit-code) since Mon 2024-06-24 14:50:48 CST; 26min ago</span><br><span class="line">    Process: 1004 ExecStart=/usr/bin/kdumpctl start (code=exited, status=1/FAILURE)</span><br><span class="line">   Main PID: 1004 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">Jun 24 14:50:47 kvm-hkcloud01 systemd[1]: Starting Crash recovery kernel arming...</span><br><span class="line">Jun 24 14:50:48 kvm-hkcloud01 kdumpctl[1015]: No memory reserved <span class="keyword">for</span> crash kernel</span><br><span class="line">Jun 24 14:50:48 kvm-hkcloud01 kdumpctl[1015]: Starting kdump: [FAILED]</span><br><span class="line">Jun 24 14:50:48 kvm-hkcloud01 systemd[1]: kdump.service: Main process exited, code=exited, status=1/FAILURE</span><br><span class="line">Jun 24 14:50:48 kvm-hkcloud01 systemd[1]: kdump.service: Failed with result <span class="string">&#x27;exit-code&#x27;</span>.</span><br><span class="line">Jun 24 14:50:48 kvm-hkcloud01 systemd[1]: Failed to start Crash recovery kernel arming.</span><br></pre></td></tr></table></figure><h1>二、问题分析</h1><p>根据提示来看，应该是申请不到内存导致的，但从<code>free</code>的结果来看，是可以满足kdump的要求的</p><ul class="lvl-0"><li class="lvl-2">资源剩余700M+</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># free -h</span></span><br><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           967Mi        89Mi       442Mi        23Mi       436Mi       715Mi</span><br><span class="line">Swap:             0B          0B          0B</span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2">kdump的需求是512M</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># cat /proc/cmdline</span></span><br><span class="line">BOOT_IMAGE=/boot/vmlinuz-5.10.0-136.12.0.86.oe2203sp1.x86_64 root=UUID=d372d015-87b7-44ed-9860-33c9d47eedb6 ro cgroup_disable=files apparmor=0 crashkernel=512M</span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><strong>为什么会分配不到资源呢？难道是启动期间资源不足导致？</strong></p><p>接下来我将crash的内存修改为128M，发现可以启动成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前配置</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># cat /etc/default/grub</span></span><br><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DISTRIBUTOR=<span class="string">&quot;<span class="subst">$(sed &#x27;s, release .*$,,g&#x27; /etc/system-release)</span>&quot;</span></span><br><span class="line">GRUB_DEFAULT=saved</span><br><span class="line">GRUB_DISABLE_SUBMENU=<span class="literal">true</span></span><br><span class="line">GRUB_TERMINAL_OUTPUT=<span class="string">&quot;console&quot;</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;cgroup_disable=files apparmor=0 crashkernel=512M&quot;</span></span><br><span class="line">GRUB_DISABLE_RECOVERY=<span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="comment"># 修改为128</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># sed -i &#x27;s/512/128/g&#x27; /etc/default/grub</span></span><br><span class="line"><span class="comment"># 重新生成grub.cfg</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br><span class="line">Generating grub configuration file ...</span><br><span class="line">Found linux image: /boot/vmlinuz-5.10.0-136.12.0.86.oe2203sp1.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-5.10.0-136.12.0.86.oe2203sp1.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-0-rescue-7c27015c30d4409fb116e3795e6126c4</span><br><span class="line">Found initrd image: /boot/initramfs-0-rescue-7c27015c30d4409fb116e3795e6126c4.img</span><br><span class="line">Adding boot menu entry <span class="keyword">for</span> UEFI Firmware Settings ...</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 重启主机</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># reboot</span></span><br><span class="line"><span class="comment"># 查看服务</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># systemctl status kdump</span></span><br><span class="line">● kdump.service - Crash recovery kernel arming</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/system/kdump.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (exited) since Wed 2024-06-26 10:25:09 CST; 1min 12s ago</span><br><span class="line">    Process: 1002 ExecStart=/usr/bin/kdumpctl start (code=exited, status=0/SUCCESS)</span><br><span class="line">   Main PID: 1002 (code=exited, status=0/SUCCESS)</span><br><span class="line"></span><br><span class="line">Jun 26 10:25:03 kvm-hkcloud01 systemd[1]: Starting Crash recovery kernel arming...</span><br><span class="line">Jun 26 10:25:09 kvm-hkcloud01 kdumpctl[1009]: kexec: loaded kdump kernel</span><br><span class="line">Jun 26 10:25:09 kvm-hkcloud01 kdumpctl[1009]: Starting kdump: [OK]</span><br><span class="line">Jun 26 10:25:09 kvm-hkcloud01 systemd[1]: Finished Crash recovery kernel arming.</span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment">#</span></span><br><span class="line"><span class="comment"># 查看内存，可以看到内存的总量比之前少了128M，说明128M的内存已经分配给crash了。</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># free -h</span></span><br><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           839Mi        85Mi       559Mi       6.2Mi       195Mi       623Mi</span><br><span class="line">Swap:             0B          0B          0B</span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>不能分配太少的内存，如果内存太少，会有<code> Could not find a free area of memory of 0x1ddd000 bytes...</code>错误，可以通过<code> makedumpfile --mem-usage /proc/kcore</code>来估算需要多少内存。</p></blockquote><h1>结论</h1><p>虚拟机内存少，而crash设置的内存比较多，会出现因资源不足没办法给crash分配内存的情况，导致kdump启动失败，可以通过修改crash内存参数来解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、现象&lt;/h1&gt;
&lt;p&gt;openEuler启动kdump失败，显示&lt;code&gt;No memory reserved for crash kernel&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.esearch.top/categories/Linux/"/>
    
    
    <category term="openEuler" scheme="https://www.esearch.top/tags/openEuler/"/>
    
    <category term="kdump" scheme="https://www.esearch.top/tags/kdump/"/>
    
  </entry>
  
  <entry>
    <title>Linux重装系统后恢复LVM</title>
    <link href="https://www.esearch.top/posts/1208ed6f/"/>
    <id>https://www.esearch.top/posts/1208ed6f/</id>
    <published>2024-06-21T09:16:37.000Z</published>
    <updated>2024-06-21T09:23:43.453Z</updated>
    
    <content type="html"><![CDATA[<p>最近重装了操作系统，仅格式化了操作系统盘，数据盘没有动，因为数据盘之前使用<code>lvm</code>进行管理的，不能直接挂在，要先恢复<code>lvm</code>信息才能挂载。</p><blockquote><p>恢复的前提是要知道vg的名称！！！</p></blockquote><p>步骤如下：</p><ul class="lvl-0"><li class="lvl-2"><p>扫描和识别<code>pv</code>信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># pvscan</span></span><br><span class="line">  PV /dev/vdb   VG vg_data         lvm2 [&lt;30.00 GiB / 1020.00 MiB free]</span><br><span class="line">  Total: 1 [&lt;30.00 GiB] / <span class="keyword">in</span> use: 1 [&lt;30.00 GiB] / <span class="keyword">in</span> no VG: 0 [0   ]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>激活vg（前提是要知道vg的名称）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># vgchange -ay vg_data</span></span><br><span class="line">  1 logical volume(s) <span class="keyword">in</span> volume group <span class="string">&quot;vg_data&quot;</span> now active</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看是否有<code>lv</code>数据</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># lvdisplay</span></span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/vg_data/lv_data</span><br><span class="line">  LV Name                lv_data</span><br><span class="line">  VG Name                vg_data</span><br><span class="line">  LV UUID                JJOdQt-2l5h-fEHJ-MkIo-bwG3-G3YV-mfjz72</span><br><span class="line">  LV Write Access        <span class="built_in">read</span>/write</span><br><span class="line">  LV Creation host, time kvm-hkcloud01.local, 2024-02-23 11:41:13 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  <span class="comment"># open                 0</span></span><br><span class="line">  LV Size                29.00 GiB</span><br><span class="line">  Current LE             7424</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently <span class="built_in">set</span> to     8192</span><br><span class="line">  Block device           252:0</span><br><span class="line"></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>挂载</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># mount /dev/mapper/vg_data-lv_data /data</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem                   Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs                     4.0M     0  4.0M   0% /dev</span><br><span class="line">tmpfs                        484M     0  484M   0% /dev/shm</span><br><span class="line">tmpfs                        194M  5.4M  189M   3% /run</span><br><span class="line">tmpfs                        4.0M     0  4.0M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1                     50G  1.8G   46G   4% /</span><br><span class="line">tmpfs                        484M     0  484M   0% /tmp</span><br><span class="line">/dev/mapper/vg_data-lv_data   29G  3.4G   26G  12% /data</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><blockquote><ul class="lvl-1"><li class="lvl-2"><p><a href=""></a></p></li><li class="lvl-2"><p><a href=""></a></p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近重装了操作系统，仅格式化了操作系统盘，数据盘没有动，因为数据盘之前使用&lt;code&gt;lvm&lt;/code&gt;进行管理的，不能直接挂在，要先恢复&lt;code&gt;lvm&lt;/code&gt;信息才能挂载。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;恢复的前提是要知道vg的名称！！！&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.esearch.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
    <category term="文件系统" scheme="https://www.esearch.top/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux中sysrq-trigger的妙用</title>
    <link href="https://www.esearch.top/posts/c0f21a4/"/>
    <id>https://www.esearch.top/posts/c0f21a4/</id>
    <published>2024-06-21T08:13:01.000Z</published>
    <updated>2024-06-21T08:14:16.879Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>sysrq被称为魔术组合键，只要内核没有完全锁住，不管内核在做什么事情，使用这些组合键都可以搜集包括系统内存使用、CPU任务处理、进程运行状态等系统运行信息。 注意：信息的输出都在/var/log/message下</p></blockquote><p>Linux如何模拟崩溃？如何强制关机？这时候就可以使用到本文提到的<code>/proc/sysrq-trigger</code>文件了。</p><ul class="lvl-0"><li class="lvl-2"><p>故意让系统崩溃，注意这不是重启，崩溃后只能从进行硬重启才能重连上系统。（产生空指针paincz事件，触发kdump，收集vmcore，会在/var/crash目录生成）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c&quot;</span> &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>立即重新启动计算机</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;b&quot;</span> &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>立即关闭计算机</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;o&quot;</span> &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>导出内存分配的信息 （可以用/var/log/message 查看）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;m&quot;</span> &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>导出当前CPU寄存器信息和标志位的信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;p&quot;</span> &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>导出线程状态信息</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;t&quot;</span> &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>故意让系统溃</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c&quot;</span> &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>立即重新挂载所有的文件系统</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;s&quot;</span> &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>立即重新挂载所有的文件系统为只读</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;u&quot;</span> &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><p>为了安全起见，在红帽企业版Linux里面，默认SysRq组合键是关闭的。 打开这个功能，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/sysrq</span><br></pre></td></tr></table></figure><p>关闭这个功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/sysrq</span><br></pre></td></tr></table></figure><p>如果想让此功能一直生效，在/etc/sysctl.conf里面设置kernel.sysrq的值为1. 重新启动以后，此功能将会自动打开。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;sysrq被称为魔术组合键，只要内核没有完全锁住，不管内核在做什么事情，使用这些组合键都可以搜集包括系统内存使用、CPU任务处理、进程运行状态等系统运行信息。 注意：信息的输出都在/var/log/message下&lt;/p&gt;
&lt;/blockquote</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.esearch.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Jquery禁用按钮，防止重复提交</title>
    <link href="https://www.esearch.top/posts/17c655b1/"/>
    <id>https://www.esearch.top/posts/17c655b1/</id>
    <published>2024-06-21T07:58:07.000Z</published>
    <updated>2024-06-21T08:08:06.651Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>对象.prop(&quot;disabled&quot;,true)</code>可以进行禁用，<code>对象.prop(&quot;disabled&quot;,false)</code>取消禁用。</p><ul class="lvl-0"><li class="lvl-2">html代码如下</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;editEventForm&quot;</span> <span class="attr">novalidate</span>=<span class="string">&quot;novalidate&quot;</span>&gt;</span></span><br><span class="line">.....</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-footer&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:history.go(-1);&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success float-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 返回<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary float-right&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right:5px;&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2">js代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="string">&quot;#editEventForm button[type=&#x27;submit&#x27;]&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">            $(<span class="string">&quot;#editEventForm button[type=&#x27;submit&#x27;]&quot;</span>).<span class="title function_">prop</span>(<span class="string">&quot;disabled&quot;</span>,<span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果您的提交按钮设置了ID，可以使用$(“#ID名称”).prop(“disabled”,true)来操作，这样就不用写这么长了。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>可以在提交成功或失败后，执行取消禁用</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#editEventForm button[type=&#x27;submit&#x27;]&quot;</span>).<span class="title function_">prop</span>(<span class="string">&quot;disabled&quot;</span>,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><blockquote><ul class="lvl-1"><li class="lvl-2"><p><a href=""></a></p></li><li class="lvl-2"><p><a href=""></a></p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用&lt;code&gt;对象.prop(&amp;quot;disabled&amp;quot;,true)&lt;/code&gt;可以进行禁用，&lt;code&gt;对象.prop(&amp;quot;disabled&amp;quot;,false)&lt;/code&gt;取消禁用。&lt;/p&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li </summary>
      
    
    
    
    <category term="前端学习" scheme="https://www.esearch.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Jquery" scheme="https://www.esearch.top/tags/Jquery/"/>
    
  </entry>
  
  <entry>
    <title>systemd怎么查看开机自启动服务</title>
    <link href="https://www.esearch.top/posts/614dd6d8/"/>
    <id>https://www.esearch.top/posts/614dd6d8/</id>
    <published>2024-06-21T03:31:50.000Z</published>
    <updated>2024-06-21T09:54:03.126Z</updated>
    
    <content type="html"><![CDATA[<p>在CentOS 7及更高的版本中，使用<code>chkconfig</code>命令查看开机自启动信息时，发现只有几个服务被<code>SysV</code>管理的服务，没有包括<code>systemd</code>管理的服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 var]<span class="comment"># chkconfig --list</span></span><br><span class="line"></span><br><span class="line">Note: This output shows SysV services only and does not include native</span><br><span class="line">      systemd services. SysV configuration data might be overridden by native</span><br><span class="line">      systemd configuration.</span><br><span class="line"></span><br><span class="line">      If you want to list systemd services use <span class="string">&#x27;systemctl list-unit-files&#x27;</span>.</span><br><span class="line">      To see services enabled on particular target use</span><br><span class="line">      <span class="string">&#x27;systemctl list-dependencies [target]&#x27;</span>.</span><br><span class="line"></span><br><span class="line">netconsole      0:off   1:off   2:off   3:off   4:off   5:off   6:off</span><br><span class="line">network         0:off   1:off   2:on    3:on    4:on    5:on    6:off</span><br><span class="line">[root@kvm-hkcloud01 var]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>如果需要查看被<code>systemd</code>管理的服务，可以使用以下命令进行查询。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 var]<span class="comment"># systemctl list-unit-files</span></span><br></pre></td></tr></table></figure><p>更多systemd内容，可参考<a href="https://ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">https://ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在CentOS 7及更高的版本中，使用&lt;code&gt;chkconfig&lt;/code&gt;命令查看开机自启动信息时，发现只有几个服务被&lt;code&gt;SysV&lt;/code&gt;管理的服务，没有包括&lt;code&gt;systemd&lt;/code&gt;管理的服务。&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.esearch.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件的ACL</title>
    <link href="https://www.esearch.top/posts/de677c90/"/>
    <id>https://www.esearch.top/posts/de677c90/</id>
    <published>2024-06-20T07:26:54.000Z</published>
    <updated>2024-06-20T09:28:59.270Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux中，一般使用<code>chmod</code>命令对属主、用户组、其它用户为类别对文件权限进行控制，这种方式较为粗略，但也能满足日常需求。在一些特殊的场景中，如只允许某些用户能访问文件的场景，如果使用<code>chmod</code>命令进行配置，一般是将这部分用户加入到组中，然后配置组的权限。</p><p>在Linux中，还提供了一种精细化的文件权限控制方式，那就是ACL（Access Control List）</p><blockquote><p>在没有ACL技术之前,Linux系统对文件的权限控制仅可划分文件的属主、用户组、其他用户三类,随着技术的发展,传统的文件权限控制已经无法适应复杂场景下的权限控制需求,比如说一个部门(即一个用户组group)存在有多名员工(即用户,user01、user02…),针对于部门内不同职责的员工,会为其赋予不同的权限,如为user01赋予可读写权限,为user02赋予只读权限,不为user03赋予任何权限,此时由于这些员工属于同一部门,就无法为这些不同的员工进行权限的细化。为此ACL(Access Control List)访问控制列表技术应运而生,使用ACL权限控制可以提供常见权限(如rwx、ugo)权限之外的权限设,置,可以针对单一用户或组来设置特定的权限。</p></blockquote><p>使用ACL必须要有文件系统的支持，目前ext3/ext4/xfs/zfs都支持文件ACL。</p><h1>相关命令</h1><ul class="lvl-0"><li class="lvl-2"><p>setfacl：设置文件的acl</p></li><li class="lvl-2"><p>getfacl：获取文件的acl</p></li><li class="lvl-2"><p>chacl：更改文件或目录的ACL</p></li></ul><h1>操作实验</h1><h2 id="用户权限配置">用户权限配置</h2><ul class="lvl-0"><li class="lvl-2"><p>user01创建文件并配置600权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 data]<span class="comment"># su user01</span></span><br><span class="line">[user01@txy201-51 data]$ <span class="built_in">echo</span> 51yunwei.top &gt; acltest</span><br><span class="line">[user01@txy201-51 data]$ <span class="built_in">chmod</span> 600 acltest</span><br><span class="line">[user01@txy201-51 data]$ getfacl acltest</span><br><span class="line"><span class="comment"># file: acltest</span></span><br><span class="line"><span class="comment"># owner: user01</span></span><br><span class="line"><span class="comment"># group: user01</span></span><br><span class="line">user::rw-</span><br><span class="line">group::---</span><br><span class="line">other::---</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>测试user02有没有访问权限（无）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 data]<span class="comment"># su user02</span></span><br><span class="line">[user02@txy201-51 data]$ <span class="built_in">cat</span> acltest</span><br><span class="line"><span class="built_in">cat</span>: acltest: 权限不够</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>使用setfacl给user02配置权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[user01@txy201-51 data]$ setfacl -m user02:r acltest</span><br><span class="line">[user01@txy201-51 data]$ getfacl acltest</span><br><span class="line"><span class="comment"># file: acltest</span></span><br><span class="line"><span class="comment"># owner: user01</span></span><br><span class="line"><span class="comment"># group: user01</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user02:r--</span><br><span class="line">group::---</span><br><span class="line">mask::r--</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>user02测试是否能读（可以）、写文件（不可以）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 data]<span class="comment"># su user02</span></span><br><span class="line">[user02@txy201-51 data]$ <span class="built_in">cat</span> acltest</span><br><span class="line">51yunwei.top</span><br><span class="line">[user02@txy201-51 data]$ <span class="built_in">echo</span> www.51yunwei.top &gt;&gt; acltest</span><br><span class="line">bash: acltest: 权限不够</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>修改user02的权限为读写</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 data]<span class="comment"># setfacl -m user02:rw acltest</span></span><br><span class="line">[root@txy201-51 data]<span class="comment"># su user02</span></span><br><span class="line">[user02@txy201-51 data]$ <span class="built_in">echo</span> www.51yunwei.top &gt;&gt; acltest</span><br><span class="line">[user02@txy201-51 data]$ <span class="built_in">cat</span> acltest</span><br><span class="line">51yunwei.top</span><br><span class="line">www.51yunwei.top</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>删除权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 data]<span class="comment"># setfacl -x user02 acltest</span></span><br><span class="line">[root@txy201-51 data]<span class="comment"># getfacl acltest</span></span><br><span class="line"><span class="comment"># file: acltest</span></span><br><span class="line"><span class="comment"># owner: user01</span></span><br><span class="line"><span class="comment"># group: user01</span></span><br><span class="line">user::rw-</span><br><span class="line">group::---</span><br><span class="line">mask::r--</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><h2 id="组权限">组权限</h2><p>setfacl默认对用户acl进行管理，如果要为组设置acl，只需要加上一个组的标识<code>g:</code>即可。</p><ul class="lvl-0"><li class="lvl-2"><p>当前user03没有访问权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 data]<span class="comment"># id user03</span></span><br><span class="line">uid=1005(user03) gid=1006(user03) 组=1006(user03),1004(user01)</span><br><span class="line">[root@txy201-51 data]<span class="comment"># su user03</span></span><br><span class="line">[user03@txy201-51 data]$ <span class="built_in">cat</span> acltest</span><br><span class="line"><span class="built_in">cat</span>: acltest: 权限不够</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>给user01组设置权限后，user03就能访问文件了（user03也在user01组）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 data]<span class="comment"># setfacl -m g:user01:r acltest</span></span><br><span class="line">[root@txy201-51 data]<span class="comment"># su user03</span></span><br><span class="line">[user03@txy201-51 data]$ <span class="built_in">cat</span> acltest</span><br><span class="line">51yunwei.top</span><br><span class="line">www.51yunwei.top</span><br></pre></td></tr></table></figure><h1>系统文件权限的备份与恢复</h1><p>在运维过程中，最怕误操作将全局的文件权限给修改了，比如执行了<code>chmod 777 -R /</code>或<code>chown -R user01:user01 /</code>，那如果真的遇到了这种情况我们应该怎么做呢？在日常运维中，我们可以把系统权限信息进行备份，在必要时进行恢复。</p><ul class="lvl-0"><li class="lvl-2"><p>备份文件权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getfacl -p &gt; 备份文件</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>恢复文件权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl --restore=备份的文件</span><br></pre></td></tr></table></figure><h2 id="实战篇">实战篇</h2><ul class="lvl-0"><li class="lvl-2"><p>实验目录<code>/tmp/data</code>，文件结构如下</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 data]<span class="comment"># ls -lR</span></span><br><span class="line">.:</span><br><span class="line">总用量 8</span><br><span class="line">-rw-r-----+ 1 user01 user01   30 6月  20 16:13 acltest</span><br><span class="line">drwxr-xr-x  2 root   root   4096 6月  20 16:30 yunwei</span><br><span class="line"></span><br><span class="line">./yunwei:</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 1 root root 0 6月  20 16:30 51yunwei</span><br><span class="line">-rw-r--r-- 1 root root 0 6月  20 16:30 top</span><br><span class="line">-rw-r--r-- 1 root root 0 6月  20 16:30 www</span><br><span class="line">[root@txy201-51 data]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将目录的权限备份到<code>tmp_data_acl.bak下</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 data]<span class="comment"># getfacl -R -p /tmp/data &gt; tmp_data_acl.bak</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>模拟误操作，修改目录下的所有权限和属主</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 data]<span class="comment"># chown user01:user01 -R /tmp/data</span></span><br><span class="line">[root@txy201-51 data]<span class="comment"># chmod 400 -R /tmp/data</span></span><br><span class="line">[root@txy201-51 data]<span class="comment"># ls -lR</span></span><br><span class="line">.:</span><br><span class="line">总用量 12</span><br><span class="line">-r--------+ 1 user01 user01   30 6月  20 16:13 acltest</span><br><span class="line">-r--------  1 user01 user01  670 6月  20 17:24 tmp_data_acl.bak</span><br><span class="line">dr--------  2 user01 user01 4096 6月  20 16:30 yunwei</span><br><span class="line"></span><br><span class="line">./yunwei:</span><br><span class="line">总用量 0</span><br><span class="line">-r-------- 1 user01 user01 0 6月  20 16:30 51yunwei</span><br><span class="line">-r-------- 1 user01 user01 0 6月  20 16:30 top</span><br><span class="line">-r-------- 1 user01 user01 0 6月  20 16:30 www</span><br><span class="line">[root@txy201-51 data]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>恢复权限，可以看到权限已恢复正常。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 data]<span class="comment"># setfacl --restore=tmp_data_acl.bak</span></span><br><span class="line">[root@txy201-51 data]<span class="comment"># ls -lR</span></span><br><span class="line">.:</span><br><span class="line">总用量 12</span><br><span class="line">-rw-rw----+ 1 user01 user01   30 6月  20 16:13 acltest</span><br><span class="line">-rw-r--r--  1 root   root    670 6月  20 17:24 tmp_data_acl.bak</span><br><span class="line">drwxr-xr-x  2 root   root   4096 6月  20 16:30 yunwei</span><br><span class="line"></span><br><span class="line">./yunwei:</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 1 root root 0 6月  20 16:30 51yunwei</span><br><span class="line">-rw-r--r-- 1 root root 0 6月  20 16:30 top</span><br><span class="line">-rw-r--r-- 1 root root 0 6月  20 16:30 www</span><br><span class="line">[root@txy201-51 data]<span class="comment">#</span></span><br></pre></td></tr></table></figure><blockquote><p>如果没有提前备份的话，可以同其它相同系统做一次备份，将文件拷贝过来做恢复，对于没在备份中的文件，权限不会被修改。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Linux中，一般使用&lt;code&gt;chmod&lt;/code&gt;命令对属主、用户组、其它用户为类别对文件权限进行控制，这种方式较为粗略，但也能满足日常需求。在一些特殊的场景中，如只允许某些用户能访问文件的场景，如果使用&lt;code&gt;chmod&lt;/code&gt;命令进行配置，一般是将这</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.esearch.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.esearch.top/tags/Linux/"/>
    
    <category term="权限" scheme="https://www.esearch.top/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的用户ID会不会重复？</title>
    <link href="https://www.esearch.top/posts/a0e0543a/"/>
    <id>https://www.esearch.top/posts/a0e0543a/</id>
    <published>2024-06-18T03:13:16.000Z</published>
    <updated>2024-06-20T09:30:53.493Z</updated>
    
    <content type="html"><![CDATA[<p><code>UID</code>指的是用户的<code>ID</code>(User ID)，一个用户的UID标识一个给定用户，UID是用户的唯一标识符，通过UID可以区分不同的用户类别，比如UID为0的是超级用户，UID为1000-600000之间的是普通用户，而UID为1-999之间的是虚拟用户。</p><ul class="lvl-0"><li class="lvl-2">超级用户：也称为root用户，UID为0，拥有系统的完全控制权限，可以进行修改、删除文件等操作。</li><li class="lvl-2">普通用户：也成为一般用户，UID为1000-60000之间，可以对自己目录下的文件进行访问和修改，也可以对经过授权的文件进行访问。</li><li class="lvl-2">虚拟用户：也称为系统用户，UID为1-999之间，不提供密码登录系统，它们的存在主要是为了方便系统的管理。</li></ul><p>Linux中的用户ID会不会重复？会，可以人为将多个不用户的ID配置为重复的ID。</p><p><strong>用户在登录系统时，是通过UID来区分用户，而不是通过用户名来区分</strong><br>实验步骤：<br>1、创建一个UID为1000的用户user02，再创建一个相同id的user01，通过id命令，发现两个用户都显示为user02</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># useradd -u 1000 user02</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># useradd -u 1000 -o user01</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># id user01</span></span><br><span class="line">uid=1000(user02) gid=1002(user02) <span class="built_in">groups</span>=1002(user02)</span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># id user02</span></span><br><span class="line">uid=1000(user02) gid=1002(user02) <span class="built_in">groups</span>=1002(user02)</span><br></pre></td></tr></table></figure><p>2、切换到user01下，发现名称还是user02，但是组信息变为了user01的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># su - user01</span></span><br><span class="line">Last login: Tue Jun 18 11:35:27 CST 2024 on pts/0</span><br><span class="line">[user02@kvm-hkcloud01 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1000(user02) gid=1003(user01) <span class="built_in">groups</span>=1003(user01)</span><br><span class="line">[user02@kvm-hkcloud01 ~]$</span><br></pre></td></tr></table></figure><p>3、当user02的uid发生改变时，再查看user01的信息，因为没有重复的id的情况下，用户名就能正常的显示user01了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># usermod -u 1001 user02</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># id user02</span></span><br><span class="line">uid=1001(user02) gid=1002(user02) <span class="built_in">groups</span>=1002(user02)</span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># id user01</span></span><br><span class="line">uid=1000(user01) gid=1003(user01) <span class="built_in">groups</span>=1003(user01)</span><br></pre></td></tr></table></figure><p>4、当我再将user02的uid修改为1000的时候，再查看user01的信息，发现user01的用户名又显示为user02了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># usermod -u 1000 -o user02</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># id user02</span></span><br><span class="line">uid=1000(user02) gid=1002(user02) <span class="built_in">groups</span>=1002(user02)</span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># id user01</span></span><br><span class="line">uid=1000(user02) gid=1002(user02) <span class="built_in">groups</span>=1002(user02)</span><br></pre></td></tr></table></figure><p><strong>那么，当UID重复的时候，是谁决定了用哪个用户名作为显示呢？</strong><br>想一想，哪个文件记录了UID信息？没错,是<code>/etc/passwd</code>当我将user01和user02的行进行调转之后（user01）在前，使用id查看的时候，显示的用户名就是user01了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># tail -n 2 /etc/passwd</span></span><br><span class="line">user02:x:1000:1002::/home/user02:/bin/bash</span><br><span class="line">user01:x:1000:1003::/home/user01:/bin/bash</span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># id user01</span></span><br><span class="line">uid=1000(user02) gid=1002(user02) <span class="built_in">groups</span>=1002(user02)</span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># id user02</span></span><br><span class="line">uid=1000(user02) gid=1002(user02) <span class="built_in">groups</span>=1002(user02)</span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># vi /etc/passwd</span></span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># tail -n 2 /etc/passwd</span></span><br><span class="line">user01:x:1000:1003::/home/user01:/bin/bash</span><br><span class="line">user02:x:1000:1002::/home/user02:/bin/bash</span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># id user01</span></span><br><span class="line">uid=1000(user01) gid=1003(user01) <span class="built_in">groups</span>=1003(user01)</span><br><span class="line">[root@kvm-hkcloud01 ~]<span class="comment"># id user02</span></span><br><span class="line">uid=1000(user01) gid=1003(user01) <span class="built_in">groups</span>=1003(user01)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;UID&lt;/code&gt;指的是用户的&lt;code&gt;ID&lt;/code&gt;(User ID)，一个用户的UID标识一个给定用户，UID是用户的唯一标识符，通过UID可以区分不同的用户类别，比如UID为0的是超级用户，UID为1000-600000之间的是普通用户，而UID为</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.esearch.top/categories/Linux/"/>
    
    
    <category term="Linux基础" scheme="https://www.esearch.top/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>怎么判断多台虚拟机上的磁盘是不是同一块磁盘呢？</title>
    <link href="https://www.esearch.top/posts/b6ae4c2c/"/>
    <id>https://www.esearch.top/posts/b6ae4c2c/</id>
    <published>2024-05-31T08:30:15.000Z</published>
    <updated>2024-05-31T08:34:46.812Z</updated>
    
    <content type="html"><![CDATA[<p>在虚拟化环境上，有普通磁盘和共享磁盘，有时候进行扩容后，多台虚拟机上的磁盘大小一样，那怎么判断某个盘是不是共享磁盘呢？这时候我们可以使用<code>blkid</code>命令来查看。</p><p>命令输出结果如下，如果多台虚拟机输出的<code>uuid</code>是一样的，那这个磁盘就是共享磁盘了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@txy201-51 tmp]<span class="comment"># blkid /dev/vda1</span></span><br><span class="line">/dev/vda1: UUID=<span class="string">&quot;4b499d76-769a-40a0-93dc-4a31a59add28&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在虚拟化环境上，有普通磁盘和共享磁盘，有时候进行扩容后，多台虚拟机上的磁盘大小一样，那怎么判断某个盘是不是共享磁盘呢？这时候我们可以使用&lt;code&gt;blkid&lt;/code&gt;命令来查看。&lt;/p&gt;
&lt;p&gt;命令输出结果如下，如果多台虚拟机输出的&lt;code&gt;uuid&lt;/code&gt;是</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.esearch.top/categories/Linux/"/>
    
    
    <category term="Linux基础" scheme="https://www.esearch.top/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
